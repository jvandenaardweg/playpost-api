// Code generated by Prisma (prisma@1.25.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  article: (where?: ArticleWhereInput) => Promise<boolean>;
  audiofile: (where?: AudiofileWhereInput) => Promise<boolean>;
  source: (where?: SourceWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  article: (where: ArticleWhereUniqueInput) => ArticlePromise;
  articles: (args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Article>;
  articlesConnection: (args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ArticleConnectionPromise;
  audiofile: (where: AudiofileWhereUniqueInput) => AudiofilePromise;
  audiofiles: (args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Audiofile>;
  audiofilesConnection: (args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AudiofileConnectionPromise;
  source: (where: SourceWhereUniqueInput) => SourcePromise;
  sources: (args?: {
    where?: SourceWhereInput;
    orderBy?: SourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Source>;
  sourcesConnection: (args?: {
    where?: SourceWhereInput;
    orderBy?: SourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SourceConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createArticle: (data: ArticleCreateInput) => ArticlePromise;
  updateArticle: (args: {
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
  }) => ArticlePromise;
  updateManyArticles: (args: {
    data: ArticleUpdateManyMutationInput;
    where?: ArticleWhereInput;
  }) => BatchPayloadPromise;
  upsertArticle: (args: {
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
  }) => ArticlePromise;
  deleteArticle: (where: ArticleWhereUniqueInput) => ArticlePromise;
  deleteManyArticles: (where?: ArticleWhereInput) => BatchPayloadPromise;
  createAudiofile: (data: AudiofileCreateInput) => AudiofilePromise;
  updateAudiofile: (args: {
    data: AudiofileUpdateInput;
    where: AudiofileWhereUniqueInput;
  }) => AudiofilePromise;
  updateManyAudiofiles: (args: {
    data: AudiofileUpdateManyMutationInput;
    where?: AudiofileWhereInput;
  }) => BatchPayloadPromise;
  upsertAudiofile: (args: {
    where: AudiofileWhereUniqueInput;
    create: AudiofileCreateInput;
    update: AudiofileUpdateInput;
  }) => AudiofilePromise;
  deleteAudiofile: (where: AudiofileWhereUniqueInput) => AudiofilePromise;
  deleteManyAudiofiles: (where?: AudiofileWhereInput) => BatchPayloadPromise;
  createSource: (data: SourceCreateInput) => SourcePromise;
  updateSource: (args: {
    data: SourceUpdateInput;
    where: SourceWhereUniqueInput;
  }) => SourcePromise;
  updateManySources: (args: {
    data: SourceUpdateManyMutationInput;
    where?: SourceWhereInput;
  }) => BatchPayloadPromise;
  upsertSource: (args: {
    where: SourceWhereUniqueInput;
    create: SourceCreateInput;
    update: SourceUpdateInput;
  }) => SourcePromise;
  deleteSource: (where: SourceWhereUniqueInput) => SourcePromise;
  deleteManySources: (where?: SourceWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  article: (
    where?: ArticleSubscriptionWhereInput
  ) => ArticleSubscriptionPayloadSubscription;
  audiofile: (
    where?: AudiofileSubscriptionWhereInput
  ) => AudiofileSubscriptionPayloadSubscription;
  source: (
    where?: SourceSubscriptionWhereInput
  ) => SourceSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Language = "EN" | "DE" | "NL";

export type Synthesizer = "GOOGLE" | "AWS";

export type ArticleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subtitle_ASC"
  | "subtitle_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "readingTime_ASC"
  | "readingTime_DESC"
  | "language_ASC"
  | "language_DESC"
  | "authorName_ASC"
  | "authorName_DESC"
  | "authorUrl_ASC"
  | "authorUrl_DESC"
  | "publicationName_ASC"
  | "publicationName_DESC"
  | "publicationUrl_ASC"
  | "publicationUrl_DESC"
  | "sourceArticleId_ASC"
  | "sourceArticleId_DESC"
  | "html_ASC"
  | "html_DESC"
  | "ssml_ASC"
  | "ssml_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AudiofileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "length_ASC"
  | "length_DESC"
  | "language_ASC"
  | "language_DESC"
  | "voice_ASC"
  | "voice_DESC"
  | "synthesizer_ASC"
  | "synthesizer_DESC"
  | "listens_ASC"
  | "listens_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ArticleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export interface ArticleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  subtitle?: String;
  subtitle_not?: String;
  subtitle_in?: String[] | String;
  subtitle_not_in?: String[] | String;
  subtitle_lt?: String;
  subtitle_lte?: String;
  subtitle_gt?: String;
  subtitle_gte?: String;
  subtitle_contains?: String;
  subtitle_not_contains?: String;
  subtitle_starts_with?: String;
  subtitle_not_starts_with?: String;
  subtitle_ends_with?: String;
  subtitle_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  imageUrl?: String;
  imageUrl_not?: String;
  imageUrl_in?: String[] | String;
  imageUrl_not_in?: String[] | String;
  imageUrl_lt?: String;
  imageUrl_lte?: String;
  imageUrl_gt?: String;
  imageUrl_gte?: String;
  imageUrl_contains?: String;
  imageUrl_not_contains?: String;
  imageUrl_starts_with?: String;
  imageUrl_not_starts_with?: String;
  imageUrl_ends_with?: String;
  imageUrl_not_ends_with?: String;
  readingTime?: Float;
  readingTime_not?: Float;
  readingTime_in?: Float[] | Float;
  readingTime_not_in?: Float[] | Float;
  readingTime_lt?: Float;
  readingTime_lte?: Float;
  readingTime_gt?: Float;
  readingTime_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  authorName?: String;
  authorName_not?: String;
  authorName_in?: String[] | String;
  authorName_not_in?: String[] | String;
  authorName_lt?: String;
  authorName_lte?: String;
  authorName_gt?: String;
  authorName_gte?: String;
  authorName_contains?: String;
  authorName_not_contains?: String;
  authorName_starts_with?: String;
  authorName_not_starts_with?: String;
  authorName_ends_with?: String;
  authorName_not_ends_with?: String;
  authorUrl?: String;
  authorUrl_not?: String;
  authorUrl_in?: String[] | String;
  authorUrl_not_in?: String[] | String;
  authorUrl_lt?: String;
  authorUrl_lte?: String;
  authorUrl_gt?: String;
  authorUrl_gte?: String;
  authorUrl_contains?: String;
  authorUrl_not_contains?: String;
  authorUrl_starts_with?: String;
  authorUrl_not_starts_with?: String;
  authorUrl_ends_with?: String;
  authorUrl_not_ends_with?: String;
  publicationName?: String;
  publicationName_not?: String;
  publicationName_in?: String[] | String;
  publicationName_not_in?: String[] | String;
  publicationName_lt?: String;
  publicationName_lte?: String;
  publicationName_gt?: String;
  publicationName_gte?: String;
  publicationName_contains?: String;
  publicationName_not_contains?: String;
  publicationName_starts_with?: String;
  publicationName_not_starts_with?: String;
  publicationName_ends_with?: String;
  publicationName_not_ends_with?: String;
  publicationUrl?: String;
  publicationUrl_not?: String;
  publicationUrl_in?: String[] | String;
  publicationUrl_not_in?: String[] | String;
  publicationUrl_lt?: String;
  publicationUrl_lte?: String;
  publicationUrl_gt?: String;
  publicationUrl_gte?: String;
  publicationUrl_contains?: String;
  publicationUrl_not_contains?: String;
  publicationUrl_starts_with?: String;
  publicationUrl_not_starts_with?: String;
  publicationUrl_ends_with?: String;
  publicationUrl_not_ends_with?: String;
  source?: SourceWhereInput;
  sourceArticleId?: String;
  sourceArticleId_not?: String;
  sourceArticleId_in?: String[] | String;
  sourceArticleId_not_in?: String[] | String;
  sourceArticleId_lt?: String;
  sourceArticleId_lte?: String;
  sourceArticleId_gt?: String;
  sourceArticleId_gte?: String;
  sourceArticleId_contains?: String;
  sourceArticleId_not_contains?: String;
  sourceArticleId_starts_with?: String;
  sourceArticleId_not_starts_with?: String;
  sourceArticleId_ends_with?: String;
  sourceArticleId_not_ends_with?: String;
  html?: String;
  html_not?: String;
  html_in?: String[] | String;
  html_not_in?: String[] | String;
  html_lt?: String;
  html_lte?: String;
  html_gt?: String;
  html_gte?: String;
  html_contains?: String;
  html_not_contains?: String;
  html_starts_with?: String;
  html_not_starts_with?: String;
  html_ends_with?: String;
  html_not_ends_with?: String;
  ssml?: String;
  ssml_not?: String;
  ssml_in?: String[] | String;
  ssml_not_in?: String[] | String;
  ssml_lt?: String;
  ssml_lte?: String;
  ssml_gt?: String;
  ssml_gte?: String;
  ssml_contains?: String;
  ssml_not_contains?: String;
  ssml_starts_with?: String;
  ssml_not_starts_with?: String;
  ssml_ends_with?: String;
  ssml_not_ends_with?: String;
  audiofiles_every?: AudiofileWhereInput;
  audiofiles_some?: AudiofileWhereInput;
  audiofiles_none?: AudiofileWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ArticleWhereInput[] | ArticleWhereInput;
  OR?: ArticleWhereInput[] | ArticleWhereInput;
  NOT?: ArticleWhereInput[] | ArticleWhereInput;
}

export interface SourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  articles_every?: ArticleWhereInput;
  articles_some?: ArticleWhereInput;
  articles_none?: ArticleWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SourceWhereInput[] | SourceWhereInput;
  OR?: SourceWhereInput[] | SourceWhereInput;
  NOT?: SourceWhereInput[] | SourceWhereInput;
}

export interface AudiofileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  article?: ArticleWhereInput;
  length?: Float;
  length_not?: Float;
  length_in?: Float[] | Float;
  length_not_in?: Float[] | Float;
  length_lt?: Float;
  length_lte?: Float;
  length_gt?: Float;
  length_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  voice?: String;
  voice_not?: String;
  voice_in?: String[] | String;
  voice_not_in?: String[] | String;
  voice_lt?: String;
  voice_lte?: String;
  voice_gt?: String;
  voice_gte?: String;
  voice_contains?: String;
  voice_not_contains?: String;
  voice_starts_with?: String;
  voice_not_starts_with?: String;
  voice_ends_with?: String;
  voice_not_ends_with?: String;
  synthesizer?: Synthesizer;
  synthesizer_not?: Synthesizer;
  synthesizer_in?: Synthesizer[] | Synthesizer;
  synthesizer_not_in?: Synthesizer[] | Synthesizer;
  listens?: Int;
  listens_not?: Int;
  listens_in?: Int[] | Int;
  listens_not_in?: Int[] | Int;
  listens_lt?: Int;
  listens_lte?: Int;
  listens_gt?: Int;
  listens_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AudiofileWhereInput[] | AudiofileWhereInput;
  OR?: AudiofileWhereInput[] | AudiofileWhereInput;
  NOT?: AudiofileWhereInput[] | AudiofileWhereInput;
}

export interface TagWhereInput {
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export type AudiofileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export type SourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
  url?: String;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  slug: String;
  name?: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ArticleCreateInput {
  title: String;
  subtitle?: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  source: SourceCreateOneWithoutArticlesInput;
  sourceArticleId: String;
  html: String;
  ssml: String;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  tags?: TagCreateManyInput;
}

export interface SourceCreateOneWithoutArticlesInput {
  create?: SourceCreateWithoutArticlesInput;
  connect?: SourceWhereUniqueInput;
}

export interface SourceCreateWithoutArticlesInput {
  name: String;
  description?: String;
  url: String;
}

export interface AudiofileCreateManyWithoutArticleInput {
  create?:
    | AudiofileCreateWithoutArticleInput[]
    | AudiofileCreateWithoutArticleInput;
  connect?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
}

export interface AudiofileCreateWithoutArticleInput {
  url: String;
  length: Float;
  language: Language;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TagCreateInput {
  slug: String;
  name: String;
}

export interface ArticleUpdateInput {
  title?: String;
  subtitle?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  source?: SourceUpdateOneRequiredWithoutArticlesInput;
  sourceArticleId?: String;
  html?: String;
  ssml?: String;
  audiofiles?: AudiofileUpdateManyWithoutArticleInput;
  tags?: TagUpdateManyInput;
}

export interface SourceUpdateOneRequiredWithoutArticlesInput {
  create?: SourceCreateWithoutArticlesInput;
  update?: SourceUpdateWithoutArticlesDataInput;
  upsert?: SourceUpsertWithoutArticlesInput;
  connect?: SourceWhereUniqueInput;
}

export interface SourceUpdateWithoutArticlesDataInput {
  name?: String;
  description?: String;
  url?: String;
}

export interface SourceUpsertWithoutArticlesInput {
  update: SourceUpdateWithoutArticlesDataInput;
  create: SourceCreateWithoutArticlesInput;
}

export interface AudiofileUpdateManyWithoutArticleInput {
  create?:
    | AudiofileCreateWithoutArticleInput[]
    | AudiofileCreateWithoutArticleInput;
  delete?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  connect?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  disconnect?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  update?:
    | AudiofileUpdateWithWhereUniqueWithoutArticleInput[]
    | AudiofileUpdateWithWhereUniqueWithoutArticleInput;
  upsert?:
    | AudiofileUpsertWithWhereUniqueWithoutArticleInput[]
    | AudiofileUpsertWithWhereUniqueWithoutArticleInput;
  deleteMany?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
  updateMany?:
    | AudiofileUpdateManyWithWhereNestedInput[]
    | AudiofileUpdateManyWithWhereNestedInput;
}

export interface AudiofileUpdateWithWhereUniqueWithoutArticleInput {
  where: AudiofileWhereUniqueInput;
  data: AudiofileUpdateWithoutArticleDataInput;
}

export interface AudiofileUpdateWithoutArticleDataInput {
  url?: String;
  length?: Float;
  language?: Language;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface AudiofileUpsertWithWhereUniqueWithoutArticleInput {
  where: AudiofileWhereUniqueInput;
  update: AudiofileUpdateWithoutArticleDataInput;
  create: AudiofileCreateWithoutArticleInput;
}

export interface AudiofileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  length?: Float;
  length_not?: Float;
  length_in?: Float[] | Float;
  length_not_in?: Float[] | Float;
  length_lt?: Float;
  length_lte?: Float;
  length_gt?: Float;
  length_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  voice?: String;
  voice_not?: String;
  voice_in?: String[] | String;
  voice_not_in?: String[] | String;
  voice_lt?: String;
  voice_lte?: String;
  voice_gt?: String;
  voice_gte?: String;
  voice_contains?: String;
  voice_not_contains?: String;
  voice_starts_with?: String;
  voice_not_starts_with?: String;
  voice_ends_with?: String;
  voice_not_ends_with?: String;
  synthesizer?: Synthesizer;
  synthesizer_not?: Synthesizer;
  synthesizer_in?: Synthesizer[] | Synthesizer;
  synthesizer_not_in?: Synthesizer[] | Synthesizer;
  listens?: Int;
  listens_not?: Int;
  listens_in?: Int[] | Int;
  listens_not_in?: Int[] | Int;
  listens_lt?: Int;
  listens_lte?: Int;
  listens_gt?: Int;
  listens_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
  OR?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
  NOT?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
}

export interface AudiofileUpdateManyWithWhereNestedInput {
  where: AudiofileScalarWhereInput;
  data: AudiofileUpdateManyDataInput;
}

export interface AudiofileUpdateManyDataInput {
  url?: String;
  length?: Float;
  language?: Language;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  slug?: String;
  name?: String;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  slug?: String;
  name?: String;
}

export interface ArticleUpdateManyMutationInput {
  title?: String;
  subtitle?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  sourceArticleId?: String;
  html?: String;
  ssml?: String;
}

export interface AudiofileCreateInput {
  url: String;
  article: ArticleCreateOneWithoutAudiofilesInput;
  length: Float;
  language: Language;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
}

export interface ArticleCreateOneWithoutAudiofilesInput {
  create?: ArticleCreateWithoutAudiofilesInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutAudiofilesInput {
  title: String;
  subtitle?: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  source: SourceCreateOneWithoutArticlesInput;
  sourceArticleId: String;
  html: String;
  ssml: String;
  tags?: TagCreateManyInput;
}

export interface AudiofileUpdateInput {
  url?: String;
  article?: ArticleUpdateOneRequiredWithoutAudiofilesInput;
  length?: Float;
  language?: Language;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface ArticleUpdateOneRequiredWithoutAudiofilesInput {
  create?: ArticleCreateWithoutAudiofilesInput;
  update?: ArticleUpdateWithoutAudiofilesDataInput;
  upsert?: ArticleUpsertWithoutAudiofilesInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleUpdateWithoutAudiofilesDataInput {
  title?: String;
  subtitle?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  source?: SourceUpdateOneRequiredWithoutArticlesInput;
  sourceArticleId?: String;
  html?: String;
  ssml?: String;
  tags?: TagUpdateManyInput;
}

export interface ArticleUpsertWithoutAudiofilesInput {
  update: ArticleUpdateWithoutAudiofilesDataInput;
  create: ArticleCreateWithoutAudiofilesInput;
}

export interface AudiofileUpdateManyMutationInput {
  url?: String;
  length?: Float;
  language?: Language;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface SourceCreateInput {
  name: String;
  description?: String;
  url: String;
  articles?: ArticleCreateManyWithoutSourceInput;
}

export interface ArticleCreateManyWithoutSourceInput {
  create?: ArticleCreateWithoutSourceInput[] | ArticleCreateWithoutSourceInput;
  connect?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutSourceInput {
  title: String;
  subtitle?: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  sourceArticleId: String;
  html: String;
  ssml: String;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  tags?: TagCreateManyInput;
}

export interface SourceUpdateInput {
  name?: String;
  description?: String;
  url?: String;
  articles?: ArticleUpdateManyWithoutSourceInput;
}

export interface ArticleUpdateManyWithoutSourceInput {
  create?: ArticleCreateWithoutSourceInput[] | ArticleCreateWithoutSourceInput;
  delete?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  connect?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  disconnect?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  update?:
    | ArticleUpdateWithWhereUniqueWithoutSourceInput[]
    | ArticleUpdateWithWhereUniqueWithoutSourceInput;
  upsert?:
    | ArticleUpsertWithWhereUniqueWithoutSourceInput[]
    | ArticleUpsertWithWhereUniqueWithoutSourceInput;
  deleteMany?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
  updateMany?:
    | ArticleUpdateManyWithWhereNestedInput[]
    | ArticleUpdateManyWithWhereNestedInput;
}

export interface ArticleUpdateWithWhereUniqueWithoutSourceInput {
  where: ArticleWhereUniqueInput;
  data: ArticleUpdateWithoutSourceDataInput;
}

export interface ArticleUpdateWithoutSourceDataInput {
  title?: String;
  subtitle?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  sourceArticleId?: String;
  html?: String;
  ssml?: String;
  audiofiles?: AudiofileUpdateManyWithoutArticleInput;
  tags?: TagUpdateManyInput;
}

export interface ArticleUpsertWithWhereUniqueWithoutSourceInput {
  where: ArticleWhereUniqueInput;
  update: ArticleUpdateWithoutSourceDataInput;
  create: ArticleCreateWithoutSourceInput;
}

export interface ArticleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  subtitle?: String;
  subtitle_not?: String;
  subtitle_in?: String[] | String;
  subtitle_not_in?: String[] | String;
  subtitle_lt?: String;
  subtitle_lte?: String;
  subtitle_gt?: String;
  subtitle_gte?: String;
  subtitle_contains?: String;
  subtitle_not_contains?: String;
  subtitle_starts_with?: String;
  subtitle_not_starts_with?: String;
  subtitle_ends_with?: String;
  subtitle_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  imageUrl?: String;
  imageUrl_not?: String;
  imageUrl_in?: String[] | String;
  imageUrl_not_in?: String[] | String;
  imageUrl_lt?: String;
  imageUrl_lte?: String;
  imageUrl_gt?: String;
  imageUrl_gte?: String;
  imageUrl_contains?: String;
  imageUrl_not_contains?: String;
  imageUrl_starts_with?: String;
  imageUrl_not_starts_with?: String;
  imageUrl_ends_with?: String;
  imageUrl_not_ends_with?: String;
  readingTime?: Float;
  readingTime_not?: Float;
  readingTime_in?: Float[] | Float;
  readingTime_not_in?: Float[] | Float;
  readingTime_lt?: Float;
  readingTime_lte?: Float;
  readingTime_gt?: Float;
  readingTime_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  authorName?: String;
  authorName_not?: String;
  authorName_in?: String[] | String;
  authorName_not_in?: String[] | String;
  authorName_lt?: String;
  authorName_lte?: String;
  authorName_gt?: String;
  authorName_gte?: String;
  authorName_contains?: String;
  authorName_not_contains?: String;
  authorName_starts_with?: String;
  authorName_not_starts_with?: String;
  authorName_ends_with?: String;
  authorName_not_ends_with?: String;
  authorUrl?: String;
  authorUrl_not?: String;
  authorUrl_in?: String[] | String;
  authorUrl_not_in?: String[] | String;
  authorUrl_lt?: String;
  authorUrl_lte?: String;
  authorUrl_gt?: String;
  authorUrl_gte?: String;
  authorUrl_contains?: String;
  authorUrl_not_contains?: String;
  authorUrl_starts_with?: String;
  authorUrl_not_starts_with?: String;
  authorUrl_ends_with?: String;
  authorUrl_not_ends_with?: String;
  publicationName?: String;
  publicationName_not?: String;
  publicationName_in?: String[] | String;
  publicationName_not_in?: String[] | String;
  publicationName_lt?: String;
  publicationName_lte?: String;
  publicationName_gt?: String;
  publicationName_gte?: String;
  publicationName_contains?: String;
  publicationName_not_contains?: String;
  publicationName_starts_with?: String;
  publicationName_not_starts_with?: String;
  publicationName_ends_with?: String;
  publicationName_not_ends_with?: String;
  publicationUrl?: String;
  publicationUrl_not?: String;
  publicationUrl_in?: String[] | String;
  publicationUrl_not_in?: String[] | String;
  publicationUrl_lt?: String;
  publicationUrl_lte?: String;
  publicationUrl_gt?: String;
  publicationUrl_gte?: String;
  publicationUrl_contains?: String;
  publicationUrl_not_contains?: String;
  publicationUrl_starts_with?: String;
  publicationUrl_not_starts_with?: String;
  publicationUrl_ends_with?: String;
  publicationUrl_not_ends_with?: String;
  sourceArticleId?: String;
  sourceArticleId_not?: String;
  sourceArticleId_in?: String[] | String;
  sourceArticleId_not_in?: String[] | String;
  sourceArticleId_lt?: String;
  sourceArticleId_lte?: String;
  sourceArticleId_gt?: String;
  sourceArticleId_gte?: String;
  sourceArticleId_contains?: String;
  sourceArticleId_not_contains?: String;
  sourceArticleId_starts_with?: String;
  sourceArticleId_not_starts_with?: String;
  sourceArticleId_ends_with?: String;
  sourceArticleId_not_ends_with?: String;
  html?: String;
  html_not?: String;
  html_in?: String[] | String;
  html_not_in?: String[] | String;
  html_lt?: String;
  html_lte?: String;
  html_gt?: String;
  html_gte?: String;
  html_contains?: String;
  html_not_contains?: String;
  html_starts_with?: String;
  html_not_starts_with?: String;
  html_ends_with?: String;
  html_not_ends_with?: String;
  ssml?: String;
  ssml_not?: String;
  ssml_in?: String[] | String;
  ssml_not_in?: String[] | String;
  ssml_lt?: String;
  ssml_lte?: String;
  ssml_gt?: String;
  ssml_gte?: String;
  ssml_contains?: String;
  ssml_not_contains?: String;
  ssml_starts_with?: String;
  ssml_not_starts_with?: String;
  ssml_ends_with?: String;
  ssml_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
  OR?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
  NOT?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
}

export interface ArticleUpdateManyWithWhereNestedInput {
  where: ArticleScalarWhereInput;
  data: ArticleUpdateManyDataInput;
}

export interface ArticleUpdateManyDataInput {
  title?: String;
  subtitle?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  sourceArticleId?: String;
  html?: String;
  ssml?: String;
}

export interface SourceUpdateManyMutationInput {
  name?: String;
  description?: String;
  url?: String;
}

export interface TagUpdateInput {
  slug?: String;
  name?: String;
}

export interface TagUpdateManyMutationInput {
  slug?: String;
  name?: String;
}

export interface UserCreateInput {
  name: String;
}

export interface UserUpdateInput {
  name?: String;
}

export interface UserUpdateManyMutationInput {
  name?: String;
}

export interface ArticleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArticleWhereInput;
  AND?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
  OR?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
  NOT?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
}

export interface AudiofileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AudiofileWhereInput;
  AND?: AudiofileSubscriptionWhereInput[] | AudiofileSubscriptionWhereInput;
  OR?: AudiofileSubscriptionWhereInput[] | AudiofileSubscriptionWhereInput;
  NOT?: AudiofileSubscriptionWhereInput[] | AudiofileSubscriptionWhereInput;
}

export interface SourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SourceWhereInput;
  AND?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  OR?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  NOT?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Article {
  id: ID_Output;
  title: String;
  subtitle?: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  sourceArticleId: String;
  html: String;
  ssml: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArticlePromise extends Promise<Article>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  imageUrl: () => Promise<String>;
  readingTime: () => Promise<Float>;
  language: () => Promise<Language>;
  authorName: () => Promise<String>;
  authorUrl: () => Promise<String>;
  publicationName: () => Promise<String>;
  publicationUrl: () => Promise<String>;
  source: <T = SourcePromise>() => T;
  sourceArticleId: () => Promise<String>;
  html: () => Promise<String>;
  ssml: () => Promise<String>;
  audiofiles: <T = FragmentableArray<Audiofile>>(args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArticleSubscription
  extends Promise<AsyncIterator<Article>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  readingTime: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  authorName: () => Promise<AsyncIterator<String>>;
  authorUrl: () => Promise<AsyncIterator<String>>;
  publicationName: () => Promise<AsyncIterator<String>>;
  publicationUrl: () => Promise<AsyncIterator<String>>;
  source: <T = SourceSubscription>() => T;
  sourceArticleId: () => Promise<AsyncIterator<String>>;
  html: () => Promise<AsyncIterator<String>>;
  ssml: () => Promise<AsyncIterator<String>>;
  audiofiles: <T = Promise<AsyncIterator<AudiofileSubscription>>>(args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Source {
  id: ID_Output;
  name: String;
  description?: String;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SourcePromise extends Promise<Source>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  articles: <T = FragmentableArray<Article>>(args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SourceSubscription
  extends Promise<AsyncIterator<Source>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  articles: <T = Promise<AsyncIterator<ArticleSubscription>>>(args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Audiofile {
  id: ID_Output;
  url: String;
  length: Float;
  language: Language;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AudiofilePromise extends Promise<Audiofile>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  article: <T = ArticlePromise>() => T;
  length: () => Promise<Float>;
  language: () => Promise<Language>;
  voice: () => Promise<String>;
  synthesizer: () => Promise<Synthesizer>;
  listens: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AudiofileSubscription
  extends Promise<AsyncIterator<Audiofile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  article: <T = ArticleSubscription>() => T;
  length: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  voice: () => Promise<AsyncIterator<String>>;
  synthesizer: () => Promise<AsyncIterator<Synthesizer>>;
  listens: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Tag {
  slug: String;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  slug: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ArticleConnection {
  pageInfo: PageInfo;
  edges: ArticleEdge[];
}

export interface ArticleConnectionPromise
  extends Promise<ArticleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArticleEdge>>() => T;
  aggregate: <T = AggregateArticlePromise>() => T;
}

export interface ArticleConnectionSubscription
  extends Promise<AsyncIterator<ArticleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArticleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArticleSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ArticleEdge {
  node: Article;
  cursor: String;
}

export interface ArticleEdgePromise extends Promise<ArticleEdge>, Fragmentable {
  node: <T = ArticlePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArticleEdgeSubscription
  extends Promise<AsyncIterator<ArticleEdge>>,
    Fragmentable {
  node: <T = ArticleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArticle {
  count: Int;
}

export interface AggregateArticlePromise
  extends Promise<AggregateArticle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArticleSubscription
  extends Promise<AsyncIterator<AggregateArticle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AudiofileConnection {
  pageInfo: PageInfo;
  edges: AudiofileEdge[];
}

export interface AudiofileConnectionPromise
  extends Promise<AudiofileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AudiofileEdge>>() => T;
  aggregate: <T = AggregateAudiofilePromise>() => T;
}

export interface AudiofileConnectionSubscription
  extends Promise<AsyncIterator<AudiofileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AudiofileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAudiofileSubscription>() => T;
}

export interface AudiofileEdge {
  node: Audiofile;
  cursor: String;
}

export interface AudiofileEdgePromise
  extends Promise<AudiofileEdge>,
    Fragmentable {
  node: <T = AudiofilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AudiofileEdgeSubscription
  extends Promise<AsyncIterator<AudiofileEdge>>,
    Fragmentable {
  node: <T = AudiofileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAudiofile {
  count: Int;
}

export interface AggregateAudiofilePromise
  extends Promise<AggregateAudiofile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAudiofileSubscription
  extends Promise<AsyncIterator<AggregateAudiofile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SourceConnection {
  pageInfo: PageInfo;
  edges: SourceEdge[];
}

export interface SourceConnectionPromise
  extends Promise<SourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SourceEdge>>() => T;
  aggregate: <T = AggregateSourcePromise>() => T;
}

export interface SourceConnectionSubscription
  extends Promise<AsyncIterator<SourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSourceSubscription>() => T;
}

export interface SourceEdge {
  node: Source;
  cursor: String;
}

export interface SourceEdgePromise extends Promise<SourceEdge>, Fragmentable {
  node: <T = SourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SourceEdgeSubscription
  extends Promise<AsyncIterator<SourceEdge>>,
    Fragmentable {
  node: <T = SourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSource {
  count: Int;
}

export interface AggregateSourcePromise
  extends Promise<AggregateSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSourceSubscription
  extends Promise<AsyncIterator<AggregateSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ArticleSubscriptionPayload {
  mutation: MutationType;
  node: Article;
  updatedFields: String[];
  previousValues: ArticlePreviousValues;
}

export interface ArticleSubscriptionPayloadPromise
  extends Promise<ArticleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArticlePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArticlePreviousValuesPromise>() => T;
}

export interface ArticleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArticleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArticleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArticlePreviousValuesSubscription>() => T;
}

export interface ArticlePreviousValues {
  id: ID_Output;
  title: String;
  subtitle?: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  publicationName?: String;
  publicationUrl?: String;
  sourceArticleId: String;
  html: String;
  ssml: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArticlePreviousValuesPromise
  extends Promise<ArticlePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  imageUrl: () => Promise<String>;
  readingTime: () => Promise<Float>;
  language: () => Promise<Language>;
  authorName: () => Promise<String>;
  authorUrl: () => Promise<String>;
  publicationName: () => Promise<String>;
  publicationUrl: () => Promise<String>;
  sourceArticleId: () => Promise<String>;
  html: () => Promise<String>;
  ssml: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArticlePreviousValuesSubscription
  extends Promise<AsyncIterator<ArticlePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  readingTime: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  authorName: () => Promise<AsyncIterator<String>>;
  authorUrl: () => Promise<AsyncIterator<String>>;
  publicationName: () => Promise<AsyncIterator<String>>;
  publicationUrl: () => Promise<AsyncIterator<String>>;
  sourceArticleId: () => Promise<AsyncIterator<String>>;
  html: () => Promise<AsyncIterator<String>>;
  ssml: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AudiofileSubscriptionPayload {
  mutation: MutationType;
  node: Audiofile;
  updatedFields: String[];
  previousValues: AudiofilePreviousValues;
}

export interface AudiofileSubscriptionPayloadPromise
  extends Promise<AudiofileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AudiofilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AudiofilePreviousValuesPromise>() => T;
}

export interface AudiofileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AudiofileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AudiofileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AudiofilePreviousValuesSubscription>() => T;
}

export interface AudiofilePreviousValues {
  id: ID_Output;
  url: String;
  length: Float;
  language: Language;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AudiofilePreviousValuesPromise
  extends Promise<AudiofilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  length: () => Promise<Float>;
  language: () => Promise<Language>;
  voice: () => Promise<String>;
  synthesizer: () => Promise<Synthesizer>;
  listens: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AudiofilePreviousValuesSubscription
  extends Promise<AsyncIterator<AudiofilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  voice: () => Promise<AsyncIterator<String>>;
  synthesizer: () => Promise<AsyncIterator<Synthesizer>>;
  listens: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SourceSubscriptionPayload {
  mutation: MutationType;
  node: Source;
  updatedFields: String[];
  previousValues: SourcePreviousValues;
}

export interface SourceSubscriptionPayloadPromise
  extends Promise<SourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SourcePreviousValuesPromise>() => T;
}

export interface SourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SourcePreviousValuesSubscription>() => T;
}

export interface SourcePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SourcePreviousValuesPromise
  extends Promise<SourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SourcePreviousValuesSubscription
  extends Promise<AsyncIterator<SourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  slug: String;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  slug: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Article",
    embedded: false
  },
  {
    name: "Audiofile",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Source",
    embedded: false
  },
  {
    name: "Synthesizer",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
