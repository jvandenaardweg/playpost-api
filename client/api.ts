// tslint:disable
/**
 * Playpost API
 * This is the documentation of the Playpost API
 *
 * The version of the OpenAPI document: 2.6.1
 * Contact: support@playpost.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    id: string;
    /**
     * A label to remember why this API Key is created
     * @type {string}
     * @memberof ApiKey
     */
    label?: string | null;
    /**
     * The API Key that is used in every request to our API
     * @type {string}
     * @memberof ApiKey
     */
    key?: string;
    /**
     * A hash generated with the API Key and API Secret.  Both API Key and API Secret is needed to compare the signature.
     * @type {string}
     * @memberof ApiKey
     */
    signature?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    lastUsedAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    lastUsedIpAddress?: string | null;
    /**
     * Restrict API access to only this given domain
     * @type {string}
     * @memberof ApiKey
     */
    allowedDomain?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    updatedAt?: string;
    /**
     * 
     * @type {User}
     * @memberof ApiKey
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface Article
 */
export interface Article {
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    url: string;
    /**
     * The most unique url of an article
     * @type {string}
     * @memberof Article
     */
    canonicalUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    status?: ArticleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    sourceName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    imageUrl?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Article
     */
    readingTime?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Article
     */
    authorName?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Article
     */
    isCompatible?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    compatibilityMessage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    html?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    ssml?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    documentHtml?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    updatedAt?: string;
    /**
     * 
     * @type {User}
     * @memberof Article
     */
    user?: User;
    /**
     * 
     * @type {Language}
     * @memberof Article
     */
    language?: Language;
    /**
     * The audiofiles that belongs to this article
     * @type {Array<User>}
     * @memberof Article
     */
    audiofiles?: Array<User> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ArticleStatusEnum {
    Crawling = 'crawling',
    New = 'new',
    Finished = 'finished',
    Failed = 'failed',
    Draft = 'draft'
}

/**
 * 
 * @export
 * @interface Audiofile
 */
export interface Audiofile {
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    bucket?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    filename?: string | null;
    /**
     * The length in seconds
     * @type {number}
     * @memberof Audiofile
     */
    length?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    mimeType: AudiofileMimeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Audiofile
     */
    updatedAt: string;
    /**
     * 
     * @type {Voice}
     * @memberof Audiofile
     */
    voice: Voice;
    /**
     * 
     * @type {User}
     * @memberof Audiofile
     */
    user?: User;
}

/**
    * @export
    * @enum {string}
    */
export enum AudiofileMimeTypeEnum {
    Mpeg = 'audio/mpeg',
    Wav = 'audio/wav',
    Pcm = 'audio/pcm',
    Opus = 'audio/opus',
    Ogg = 'audio/ogg'
}

/**
 * 
 * @export
 * @interface Auth
 */
export interface Auth {
    /**
     * A JWT token
     * @type {string}
     * @memberof Auth
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof Auth
     */
    expiresAt?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Auth
     */
    expiresAtMs?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Auth
     */
    issuedAt?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Auth
     */
    issuedAtMs?: number | null;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface CountriesCollection
 */
export interface CountriesCollection {
    /**
     * 
     * @type {number}
     * @memberof CountriesCollection
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof CountriesCollection
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof CountriesCollection
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<Country>}
     * @memberof CountriesCollection
     */
    data?: Array<Country>;
}
/**
 * 
 * @export
 * @interface CountriesCollectionAllOf
 */
export interface CountriesCollectionAllOf {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CountriesCollectionAllOf
     */
    data?: Array<Country>;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    nativeName: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    continent: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    updatedAt?: string;
    /**
     * An array of languages.
     * @type {Array<Language>}
     * @memberof Country
     */
    languages?: Array<Language> | null;
}
/**
 * 
 * @export
 * @interface DeletedProduct
 */
export interface DeletedProduct {
    /**
     * Always true for a deleted object
     * @type {boolean}
     * @memberof DeletedProduct
     */
    deleted: DeletedProductDeletedEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof DeletedProduct
     */
    id: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof DeletedProduct
     */
    object: DeletedProductModelObjectEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DeletedProductDeletedEnum {
    True = 'true'
}
/**
    * @export
    * @enum {string}
    */
export enum DeletedProductModelObjectEnum {
    Product = 'product'
}

/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * The HTTP Status code
     * @type {number}
     * @memberof InlineResponse400
     */
    status?: number;
    /**
     * A string message summarizing the error
     * @type {string}
     * @memberof InlineResponse400
     */
    message?: string;
    /**
     * An additional optional object containing more information about the error
     * @type {object}
     * @memberof InlineResponse400
     */
    details?: object;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse401
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse404
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    nativeName: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    rightToLeft: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    isActive: boolean;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    updatedAt?: string;
    /**
     * An array of voices.
     * @type {Array<Voice>}
     * @memberof Language
     */
    voices?: Array<Voice> | null;
    /**
     * An array of articles.
     * @type {Array<Article>}
     * @memberof Language
     */
    articles?: Array<Article> | null;
    /**
     * An array of countries.
     * @type {Array<Country>}
     * @memberof Language
     */
    countries?: Array<Country> | null;
}
/**
 * 
 * @export
 * @interface LanguagesCollection
 */
export interface LanguagesCollection {
    /**
     * 
     * @type {number}
     * @memberof LanguagesCollection
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof LanguagesCollection
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof LanguagesCollection
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<Language>}
     * @memberof LanguagesCollection
     */
    data?: Array<Language>;
}
/**
 * 
 * @export
 * @interface LanguagesCollectionAllOf
 */
export interface LanguagesCollectionAllOf {
    /**
     * 
     * @type {Array<Language>}
     * @memberof LanguagesCollectionAllOf
     */
    data?: Array<Language>;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * The Stripe Customer ID
     * @type {string}
     * @memberof Organization
     */
    stripeCustomerId: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface PackageDimensions
 */
export interface PackageDimensions {
    /**
     * Height, in inches.
     * @type {number}
     * @memberof PackageDimensions
     */
    height: number;
    /**
     * Length, in inches.
     * @type {number}
     * @memberof PackageDimensions
     */
    length: number;
    /**
     * Weight, in ounces.
     * @type {number}
     * @memberof PackageDimensions
     */
    weight: number;
    /**
     * Width, in inches.
     * @type {number}
     * @memberof PackageDimensions
     */
    width: number;
}
/**
 * 
 * @export
 * @interface PatchAuthActivateRequestBody
 */
export interface PatchAuthActivateRequestBody {
    /**
     * A token to verify and activate a user account
     * @type {string}
     * @memberof PatchAuthActivateRequestBody
     */
    activationToken: string;
}
/**
 * 
 * @export
 * @interface PatchAuthResetPasswordRequestBody
 */
export interface PatchAuthResetPasswordRequestBody {
    /**
     * Password of the user\'s Playpost account
     * @type {string}
     * @memberof PatchAuthResetPasswordRequestBody
     */
    password: string;
    /**
     * A token to allow resetting ther user\'s password
     * @type {string}
     * @memberof PatchAuthResetPasswordRequestBody
     */
    resetPasswordToken: string;
}
/**
 * 
 * @export
 * @interface PatchOneUserRequestBody
 */
export interface PatchOneUserRequestBody {
    /**
     * 
     * @type {string}
     * @memberof PatchOneUserRequestBody
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchOneUserRequestBody
     */
    currentPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchOneUserRequestBody
     */
    newPassword?: string;
}
/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * Whether the plan is currently available for new subscriptions.
     * @type {boolean}
     * @memberof Plan
     */
    active: boolean;
    /**
     * Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
     * @type {string}
     * @memberof Plan
     */
    aggregateUsage?: PlanAggregateUsageEnum;
    /**
     * The amount in %s to be charged on the interval specified.
     * @type {number}
     * @memberof Plan
     */
    amount?: number | null;
    /**
     * Same as `amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof Plan
     */
    amountDecimal?: string | null;
    /**
     * Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
     * @type {string}
     * @memberof Plan
     */
    billingScheme?: PlanBillingSchemeEnum;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Plan
     */
    created: number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof Plan
     */
    currency: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Plan
     */
    id: string;
    /**
     * The frequency at which a subscription is billed. One of `day`, `week`, `month` or `year`.
     * @type {string}
     * @memberof Plan
     */
    interval: PlanIntervalEnum;
    /**
     * The number of intervals (specified in the `interval` attribute) between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months.
     * @type {number}
     * @memberof Plan
     */
    intervalCount: number;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof Plan
     */
    livemode: boolean;
    /**
     * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof Plan
     */
    metadata: { [key: string]: string; };
    /**
     * A brief description of the plan, hidden from customers.
     * @type {string}
     * @memberof Plan
     */
    nickname?: string | null;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof Plan
     */
    object: PlanModelObjectEnum;
    /**
     * The product whose pricing this plan determines.
     * @type {string | Product | DeletedProduct}
     * @memberof Plan
     */
    product?: string | Product | DeletedProduct | null;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
     * @type {Array<PlanTier>}
     * @memberof Plan
     */
    tiers?: Array<PlanTier> | null;
    /**
     * Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price. In `graduated` tiering, pricing can change as the quantity grows.
     * @type {string}
     * @memberof Plan
     */
    tiersMode?: PlanTiersModeEnum;
    /**
     * Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with `tiers`.
     * @type {TransformUsage}
     * @memberof Plan
     */
    transformUsage?: TransformUsage | null;
    /**
     * Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
     * @type {number}
     * @memberof Plan
     */
    trialPeriodDays?: number | null;
    /**
     * Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
     * @type {string}
     * @memberof Plan
     */
    usageType: PlanUsageTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PlanAggregateUsageEnum {
    LastDuringPeriod = 'last_during_period',
    LastEver = 'last_ever',
    Max = 'max',
    Sum = 'sum'
}
/**
    * @export
    * @enum {string}
    */
export enum PlanBillingSchemeEnum {
    PerUnit = 'per_unit',
    Tiered = 'tiered'
}
/**
    * @export
    * @enum {string}
    */
export enum PlanIntervalEnum {
    Day = 'day',
    Month = 'month',
    Week = 'week',
    Year = 'year'
}
/**
    * @export
    * @enum {string}
    */
export enum PlanModelObjectEnum {
    Plan = 'plan'
}
/**
    * @export
    * @enum {string}
    */
export enum PlanTiersModeEnum {
    Graduated = 'graduated',
    Volume = 'volume'
}
/**
    * @export
    * @enum {string}
    */
export enum PlanUsageTypeEnum {
    Licensed = 'licensed',
    Metered = 'metered'
}

/**
 * 
 * @export
 * @interface PlanTier
 */
export interface PlanTier {
    /**
     * Price for the entire tier.
     * @type {number}
     * @memberof PlanTier
     */
    flatAmount?: number | null;
    /**
     * Same as `flat_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof PlanTier
     */
    flatAmountDecimal?: string | null;
    /**
     * Per unit price for units relevant to the tier.
     * @type {number}
     * @memberof PlanTier
     */
    unitAmount?: number | null;
    /**
     * Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {string}
     * @memberof PlanTier
     */
    unitAmountDecimal?: string | null;
    /**
     * Up to and including to this quantity will be contained in the tier.
     * @type {number}
     * @memberof PlanTier
     */
    upTo?: number | null;
}
/**
 * 
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    order: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    lastPlayedAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    archivedAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    favoritedAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    updatedAt: string;
    /**
     * 
     * @type {User}
     * @memberof PlaylistItem
     */
    user: User;
    /**
     * 
     * @type {Article}
     * @memberof PlaylistItem
     */
    article: Article;
}
/**
 * 
 * @export
 * @interface PostAuthRequestBody
 */
export interface PostAuthRequestBody {
    /**
     * Email address of the user\'s Playpost account
     * @type {string}
     * @memberof PostAuthRequestBody
     */
    email: string;
    /**
     * Password of the user\'s Playpost account
     * @type {string}
     * @memberof PostAuthRequestBody
     */
    password: string;
}
/**
 * 
 * @export
 * @interface PostAuthResetPasswordMobileRequestBody
 */
export interface PostAuthResetPasswordMobileRequestBody {
    /**
     * Email address of the user\'s Playpost account
     * @type {string}
     * @memberof PostAuthResetPasswordMobileRequestBody
     */
    email: string;
}
/**
 * 
 * @export
 * @interface PostAuthResetPasswordRequestBody
 */
export interface PostAuthResetPasswordRequestBody {
    /**
     * Email address of the user\'s Playpost account
     * @type {string}
     * @memberof PostAuthResetPasswordRequestBody
     */
    email: string;
}
/**
 * 
 * @export
 * @interface PostAuthUpdatePasswordMobileRequestBody
 */
export interface PostAuthUpdatePasswordMobileRequestBody {
    /**
     * Password of the user\'s Playpost account
     * @type {string}
     * @memberof PostAuthUpdatePasswordMobileRequestBody
     */
    password: string;
    /**
     * A token to allow resetting ther user\'s password
     * @type {string}
     * @memberof PostAuthUpdatePasswordMobileRequestBody
     */
    resetPasswordToken: string;
}
/**
 * 
 * @export
 * @interface PostOneBillingTaxNumberValidationRequestBody
 */
export interface PostOneBillingTaxNumberValidationRequestBody {
    /**
     * 
     * @type {string}
     * @memberof PostOneBillingTaxNumberValidationRequestBody
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PostOneBillingTaxNumberValidationRequestBody
     */
    taxNumber?: string;
}
/**
 * 
 * @export
 * @interface PostUsersRequestBody
 */
export interface PostUsersRequestBody {
    /**
     * Email address of the user\'s Playpost account
     * @type {string}
     * @memberof PostUsersRequestBody
     */
    email: string;
    /**
     * Password of the user\'s Playpost account
     * @type {string}
     * @memberof PostUsersRequestBody
     */
    password: string;
    /**
     * Optional property to also create an Organization
     * @type {string}
     * @memberof PostUsersRequestBody
     */
    orgnaization?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Whether the product is currently available for purchase.
     * @type {boolean}
     * @memberof Product
     */
    active: boolean;
    /**
     * A list of up to 5 attributes that each SKU can provide values for (e.g., `[\"color\", \"size\"]`).
     * @type {Array<string>}
     * @memberof Product
     */
    attributes?: Array<string> | null;
    /**
     * A short one-line description of the product, meant to be displayable to the customer. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof Product
     */
    caption?: string | null;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Product
     */
    created: number;
    /**
     * An array of connect application identifiers that cannot purchase this product. Only applicable to products of `type=good`.
     * @type {Array<string>}
     * @memberof Product
     */
    deactivateOn?: Array<string>;
    /**
     * The product\'s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
     * @type {string}
     * @memberof Product
     */
    description?: string | null;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Product
     */
    id: string;
    /**
     * A list of up to 8 URLs of images for this product, meant to be displayable to the customer. Only applicable to products of `type=good`.
     * @type {Array<string>}
     * @memberof Product
     */
    images: Array<string>;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof Product
     */
    livemode: boolean;
    /**
     * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof Product
     */
    metadata: { [key: string]: string; };
    /**
     * The product\'s name, meant to be displayable to the customer. Whenever this product is sold via a subscription, name will show up on associated invoice line item descriptions.
     * @type {string}
     * @memberof Product
     */
    name: string;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof Product
     */
    object: ProductModelObjectEnum;
    /**
     * The dimensions of this product for shipping purposes. A SKU associated with this product can override this value by having its own `package_dimensions`. Only applicable to products of `type=good`.
     * @type {PackageDimensions}
     * @memberof Product
     */
    packageDimensions?: PackageDimensions | null;
    /**
     * Whether this product is a shipped good. Only applicable to products of `type=good`.
     * @type {boolean}
     * @memberof Product
     */
    shippable?: boolean | null;
    /**
     * Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used.
     * @type {string}
     * @memberof Product
     */
    statementDescriptor?: string | null;
    /**
     * The type of the product. The product is either of type `good`, which is eligible for use with Orders and SKUs, or `service`, which is eligible for use with Subscriptions and Plans.
     * @type {string}
     * @memberof Product
     */
    type: ProductTypeEnum;
    /**
     * A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
     * @type {string}
     * @memberof Product
     */
    unitLabel?: string | null;
    /**
     * Time at which the object was last updated. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Product
     */
    updated: number;
    /**
     * A URL of a publicly-accessible webpage for this product. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof Product
     */
    url?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductModelObjectEnum {
    Product = 'product'
}
/**
    * @export
    * @enum {string}
    */
export enum ProductTypeEnum {
    Good = 'good',
    Service = 'service'
}

/**
 * 
 * @export
 * @interface Publication
 */
export interface Publication {
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Publication
     */
    updatedAt?: string;
    /**
     * 
     * @type {Organization}
     * @memberof Publication
     */
    organization: Organization;
}
/**
 * 
 * @export
 * @interface SalesTax
 */
export interface SalesTax {
    /**
     * 
     * @type {string}
     * @memberof SalesTax
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof SalesTax
     */
    rate?: number;
    /**
     * 
     * @type {string}
     * @memberof SalesTax
     */
    area?: SalesTaxAreaEnum;
    /**
     * 
     * @type {string}
     * @memberof SalesTax
     */
    exchange?: SalesTaxExchangeEnum;
    /**
     * 
     * @type {SalesTaxCharge}
     * @memberof SalesTax
     */
    charge?: SalesTaxCharge;
}

/**
    * @export
    * @enum {string}
    */
export enum SalesTaxAreaEnum {
    Worldwide = 'worldwide',
    Regional = 'regional',
    National = 'national'
}
/**
    * @export
    * @enum {string}
    */
export enum SalesTaxExchangeEnum {
    Business = 'business',
    Consumer = 'consumer'
}

/**
 * 
 * @export
 * @interface SalesTaxCharge
 */
export interface SalesTaxCharge {
    /**
     * 
     * @type {boolean}
     * @memberof SalesTaxCharge
     */
    direct?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SalesTaxCharge
     */
    reverse?: boolean;
}
/**
 * 
 * @export
 * @interface TaxRate
 */
export interface TaxRate {
    /**
     * Defaults to `true`. When set to `false`, this tax rate cannot be applied to objects in the API, but will still be applied to subscriptions and invoices that already have it set.
     * @type {boolean}
     * @memberof TaxRate
     */
    active: boolean;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof TaxRate
     */
    created: number;
    /**
     * An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
     * @type {string}
     * @memberof TaxRate
     */
    description?: string | null;
    /**
     * The display name of the tax rates as it will appear to your customer on their receipt email, PDF, and the hosted invoice page.
     * @type {string}
     * @memberof TaxRate
     */
    displayName: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof TaxRate
     */
    id: string;
    /**
     * This specifies if the tax rate is inclusive or exclusive.
     * @type {boolean}
     * @memberof TaxRate
     */
    inclusive: boolean;
    /**
     * The jurisdiction for the tax rate.
     * @type {string}
     * @memberof TaxRate
     */
    jurisdiction?: string | null;
    /**
     * Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
     * @type {boolean}
     * @memberof TaxRate
     */
    livemode: boolean;
    /**
     * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof TaxRate
     */
    metadata: { [key: string]: string; };
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof TaxRate
     */
    object: TaxRateModelObjectEnum;
    /**
     * This represents the tax rate percent out of 100.
     * @type {number}
     * @memberof TaxRate
     */
    percentage: number;
}

/**
    * @export
    * @enum {string}
    */
export enum TaxRateModelObjectEnum {
    TaxRate = 'tax_rate'
}

/**
 * 
 * @export
 * @interface TransformUsage
 */
export interface TransformUsage {
    /**
     * Divide usage by this number.
     * @type {number}
     * @memberof TransformUsage
     */
    divideBy: number;
    /**
     * After division, either round the result `up` or `down`.
     * @type {string}
     * @memberof TransformUsage
     */
    round: TransformUsageRoundEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TransformUsageRoundEnum {
    Down = 'down',
    Up = 'up'
}

/**
 * 
 * @export
 * @interface UsageRecord
 */
export interface UsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof UsageRecord
     */
    quantity?: number;
    /**
     * A boolean value to determine if the user should pay for this or not
     * @type {boolean}
     * @memberof UsageRecord
     */
    isMetered?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof UsageRecord
     */
    timestamp?: number | null;
    /**
     * The Stripe Subscription Item ID used for this Usage Record in Stripe
     * @type {string}
     * @memberof UsageRecord
     */
    stripeSubscriptionItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    stripeUsageRecordId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    updatedAt?: string;
    /**
     * 
     * @type {Organization}
     * @memberof UsageRecord
     */
    organization: Organization;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    resetPasswordToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    activationToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    authenticatedAt: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    requestResetPasswordAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    resetPasswordAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    activatedAt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface UserVoiceSetting
 */
export interface UserVoiceSetting {
    /**
     * 
     * @type {string}
     * @memberof UserVoiceSetting
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserVoiceSetting
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserVoiceSetting
     */
    updatedAt: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserVoiceSetting
     */
    user?: Array<User>;
    /**
     * 
     * @type {Array<Voice>}
     * @memberof UserVoiceSetting
     */
    voice: Array<Voice>;
    /**
     * 
     * @type {Array<Language>}
     * @memberof UserVoiceSetting
     */
    language: Array<Language>;
}
/**
 * 
 * @export
 * @interface Voice
 */
export interface Voice {
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    languageCode: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    gender: VoiceGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    synthesizer: VoiceSynthesizerEnum;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    quality: VoiceQualityEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Voice
     */
    isActive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Voice
     */
    isPremium: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Voice
     */
    isLanguageDefault?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Voice
     */
    isUnsubscribedLanguageDefault?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Voice
     */
    isSubscribedLanguageDefault?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    exampleAudioUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    updatedAt?: string;
    /**
     * 
     * @type {Language}
     * @memberof Voice
     */
    language: Language;
    /**
     * 
     * @type {Country}
     * @memberof Voice
     */
    country: Country;
    /**
     * 
     * @type {Array<Audiofile>}
     * @memberof Voice
     */
    audiofiles?: Array<Audiofile> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceGenderEnum {
    MALE = 'MALE',
    FEMALE = 'FEMALE'
}
/**
    * @export
    * @enum {string}
    */
export enum VoiceSynthesizerEnum {
    Google = 'Google',
    AWS = 'AWS'
}
/**
    * @export
    * @enum {string}
    */
export enum VoiceQualityEnum {
    Normal = 'Normal',
    High = 'High',
    VeryHigh = 'Very High'
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate a user account using an activation token
         * @param {PatchAuthActivateRequestBody} [patchAuthActivateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthActivate(patchAuthActivateRequestBody?: PatchAuthActivateRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/auth/activate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchAuthActivateRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAuthActivateRequestBody !== undefined ? patchAuthActivateRequestBody : {}) : (patchAuthActivateRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change a password of a user using a resetPasswordToken
         * @summary Change a password using a reset password token
         * @param {PatchAuthResetPasswordRequestBody} [patchAuthResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthResetPassword(patchAuthResetPasswordRequestBody?: PatchAuthResetPasswordRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/auth/reset/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchAuthResetPasswordRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAuthResetPasswordRequestBody !== undefined ? patchAuthResetPasswordRequestBody : {}) : (patchAuthResetPasswordRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an authentication token using email and password
         * @param {PostAuthRequestBody} [postAuthRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuth(postAuthRequestBody?: PostAuthRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/auth`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof postAuthRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postAuthRequestBody !== undefined ? postAuthRequestBody : {}) : (postAuthRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a resetPasswordToken to allow resetting a password.
         * @summary Request a reset password token to allow resetting a password.
         * @param {PostAuthResetPasswordRequestBody} [postAuthResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthResetPassword(postAuthResetPasswordRequestBody?: PostAuthResetPasswordRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/auth/reset/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof postAuthResetPasswordRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postAuthResetPasswordRequestBody !== undefined ? postAuthResetPasswordRequestBody : {}) : (postAuthResetPasswordRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a reset password token to allow an unauthorized user to reset his account\'s password. The generated token is send to the user his e-mail address and stored in the database. The user can use that token, in combinatation with the /auth/update-password endpoint to reset his password.
         * @summary Request a reset password token (mobile app only)
         * @param {PostAuthResetPasswordMobileRequestBody} [postAuthResetPasswordMobileRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody?: PostAuthResetPasswordMobileRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/auth/reset-password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof postAuthResetPasswordMobileRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postAuthResetPasswordMobileRequestBody !== undefined ? postAuthResetPasswordMobileRequestBody : {}) : (postAuthResetPasswordMobileRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user\'s password using a reset token. This token can be requested if the user has lost his password.
         * @summary Update a password using a reset password token (mobile app only)
         * @param {PostAuthUpdatePasswordMobileRequestBody} [postAuthUpdatePasswordMobileRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody?: PostAuthUpdatePasswordMobileRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/auth/update-password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof postAuthUpdatePasswordMobileRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postAuthUpdatePasswordMobileRequestBody !== undefined ? postAuthUpdatePasswordMobileRequestBody : {}) : (postAuthUpdatePasswordMobileRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate a user account using an activation token
         * @param {PatchAuthActivateRequestBody} [patchAuthActivateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthActivate(patchAuthActivateRequestBody?: PatchAuthActivateRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).patchAuthActivate(patchAuthActivateRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Change a password of a user using a resetPasswordToken
         * @summary Change a password using a reset password token
         * @param {PatchAuthResetPasswordRequestBody} [patchAuthResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthResetPassword(patchAuthResetPasswordRequestBody?: PatchAuthResetPasswordRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).patchAuthResetPassword(patchAuthResetPasswordRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get an authentication token using email and password
         * @param {PostAuthRequestBody} [postAuthRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuth(postAuthRequestBody?: PostAuthRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).postAuth(postAuthRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request a resetPasswordToken to allow resetting a password.
         * @summary Request a reset password token to allow resetting a password.
         * @param {PostAuthResetPasswordRequestBody} [postAuthResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthResetPassword(postAuthResetPasswordRequestBody?: PostAuthResetPasswordRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).postAuthResetPassword(postAuthResetPasswordRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a reset password token to allow an unauthorized user to reset his account\'s password. The generated token is send to the user his e-mail address and stored in the database. The user can use that token, in combinatation with the /auth/update-password endpoint to reset his password.
         * @summary Request a reset password token (mobile app only)
         * @param {PostAuthResetPasswordMobileRequestBody} [postAuthResetPasswordMobileRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody?: PostAuthResetPasswordMobileRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the user\'s password using a reset token. This token can be requested if the user has lost his password.
         * @summary Update a password using a reset password token (mobile app only)
         * @param {PostAuthUpdatePasswordMobileRequestBody} [postAuthUpdatePasswordMobileRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody?: PostAuthUpdatePasswordMobileRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Activate a user account using an activation token
         * @param {PatchAuthActivateRequestBody} [patchAuthActivateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthActivate(patchAuthActivateRequestBody?: PatchAuthActivateRequestBody, options?: any): AxiosPromise<Message> {
            return AuthApiFp(configuration).patchAuthActivate(patchAuthActivateRequestBody, options)(axios, basePath);
        },
        /**
         * Change a password of a user using a resetPasswordToken
         * @summary Change a password using a reset password token
         * @param {PatchAuthResetPasswordRequestBody} [patchAuthResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthResetPassword(patchAuthResetPasswordRequestBody?: PatchAuthResetPasswordRequestBody, options?: any): AxiosPromise<Message> {
            return AuthApiFp(configuration).patchAuthResetPassword(patchAuthResetPasswordRequestBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get an authentication token using email and password
         * @param {PostAuthRequestBody} [postAuthRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuth(postAuthRequestBody?: PostAuthRequestBody, options?: any): AxiosPromise<Auth> {
            return AuthApiFp(configuration).postAuth(postAuthRequestBody, options)(axios, basePath);
        },
        /**
         * Request a resetPasswordToken to allow resetting a password.
         * @summary Request a reset password token to allow resetting a password.
         * @param {PostAuthResetPasswordRequestBody} [postAuthResetPasswordRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthResetPassword(postAuthResetPasswordRequestBody?: PostAuthResetPasswordRequestBody, options?: any): AxiosPromise<Message> {
            return AuthApiFp(configuration).postAuthResetPassword(postAuthResetPasswordRequestBody, options)(axios, basePath);
        },
        /**
         * Creates a reset password token to allow an unauthorized user to reset his account\'s password. The generated token is send to the user his e-mail address and stored in the database. The user can use that token, in combinatation with the /auth/update-password endpoint to reset his password.
         * @summary Request a reset password token (mobile app only)
         * @param {PostAuthResetPasswordMobileRequestBody} [postAuthResetPasswordMobileRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody?: PostAuthResetPasswordMobileRequestBody, options?: any): AxiosPromise<Message> {
            return AuthApiFp(configuration).postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody, options)(axios, basePath);
        },
        /**
         * Updates the user\'s password using a reset token. This token can be requested if the user has lost his password.
         * @summary Update a password using a reset password token (mobile app only)
         * @param {PostAuthUpdatePasswordMobileRequestBody} [postAuthUpdatePasswordMobileRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody?: PostAuthUpdatePasswordMobileRequestBody, options?: any): AxiosPromise<Message> {
            return AuthApiFp(configuration).postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Activate a user account using an activation token
     * @param {PatchAuthActivateRequestBody} [patchAuthActivateRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public patchAuthActivate(patchAuthActivateRequestBody?: PatchAuthActivateRequestBody, options?: any) {
        return AuthApiFp(this.configuration).patchAuthActivate(patchAuthActivateRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * Change a password of a user using a resetPasswordToken
     * @summary Change a password using a reset password token
     * @param {PatchAuthResetPasswordRequestBody} [patchAuthResetPasswordRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public patchAuthResetPassword(patchAuthResetPasswordRequestBody?: PatchAuthResetPasswordRequestBody, options?: any) {
        return AuthApiFp(this.configuration).patchAuthResetPassword(patchAuthResetPasswordRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get an authentication token using email and password
     * @param {PostAuthRequestBody} [postAuthRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuth(postAuthRequestBody?: PostAuthRequestBody, options?: any) {
        return AuthApiFp(this.configuration).postAuth(postAuthRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * Request a resetPasswordToken to allow resetting a password.
     * @summary Request a reset password token to allow resetting a password.
     * @param {PostAuthResetPasswordRequestBody} [postAuthResetPasswordRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthResetPassword(postAuthResetPasswordRequestBody?: PostAuthResetPasswordRequestBody, options?: any) {
        return AuthApiFp(this.configuration).postAuthResetPassword(postAuthResetPasswordRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * Creates a reset password token to allow an unauthorized user to reset his account\'s password. The generated token is send to the user his e-mail address and stored in the database. The user can use that token, in combinatation with the /auth/update-password endpoint to reset his password.
     * @summary Request a reset password token (mobile app only)
     * @param {PostAuthResetPasswordMobileRequestBody} [postAuthResetPasswordMobileRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody?: PostAuthResetPasswordMobileRequestBody, options?: any) {
        return AuthApiFp(this.configuration).postAuthResetPasswordMobile(postAuthResetPasswordMobileRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * Updates the user\'s password using a reset token. This token can be requested if the user has lost his password.
     * @summary Update a password using a reset password token (mobile app only)
     * @param {PostAuthUpdatePasswordMobileRequestBody} [postAuthUpdatePasswordMobileRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody?: PostAuthUpdatePasswordMobileRequestBody, options?: any) {
        return AuthApiFp(this.configuration).postAuthUpdatePasswordMobile(postAuthUpdatePasswordMobileRequestBody, options)(this.axios, this.basePath);
    }

}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all Plans from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingPlans(options: any = {}): RequestArgs {
            const localVarPath = `/billing/plans`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Products from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingProducts(options: any = {}): RequestArgs {
            const localVarPath = `/billing/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all TaxRate\'s from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingTaxRates(options: any = {}): RequestArgs {
            const localVarPath = `/billing/tax-rates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Index of billing endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingIndex(options: any = {}): RequestArgs {
            const localVarPath = `/billing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets one subscription plan from Stripe using Stripe subscription Id\'s.
         * @param {string} stripePlanId A Stripe Plan Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingPlan(stripePlanId: string, options: any = {}): RequestArgs {
            // verify required parameter 'stripePlanId' is not null or undefined
            if (stripePlanId === null || stripePlanId === undefined) {
                throw new RequiredError('stripePlanId','Required parameter stripePlanId was null or undefined when calling getOneBillingPlan.');
            }
            const localVarPath = `/billing/plans/{stripePlanId}`
                .replace(`{${"stripePlanId"}}`, encodeURIComponent(String(stripePlanId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets one Product from Stripe using Stripe Product Id.
         * @param {string} stripeProductId A Stripe Plan Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingProduct(stripeProductId: string, options: any = {}): RequestArgs {
            // verify required parameter 'stripeProductId' is not null or undefined
            if (stripeProductId === null || stripeProductId === undefined) {
                throw new RequiredError('stripeProductId','Required parameter stripeProductId was null or undefined when calling getOneBillingProduct.');
            }
            const localVarPath = `/billing/products/{stripeProductId}`
                .replace(`{${"stripeProductId"}}`, encodeURIComponent(String(stripeProductId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets one Sales Tax response by countryCode.
         * @param {string} countryCode A Country code as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingSalesTax(countryCode: string, options: any = {}): RequestArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling getOneBillingSalesTax.');
            }
            const localVarPath = `/billing/sales-tax/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets one TaxRate from Stripe using Stripe TaxRate Id.
         * @param {string} stripeTaxRateId A Stripe TaxRate Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingTaxRate(stripeTaxRateId: string, options: any = {}): RequestArgs {
            // verify required parameter 'stripeTaxRateId' is not null or undefined
            if (stripeTaxRateId === null || stripeTaxRateId === undefined) {
                throw new RequiredError('stripeTaxRateId','Required parameter stripeTaxRateId was null or undefined when calling getOneBillingTaxRate.');
            }
            const localVarPath = `/billing/tax-rate/{stripeTaxRateId}`
                .replace(`{${"stripeTaxRateId"}}`, encodeURIComponent(String(stripeTaxRateId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates a tax number.
         * @param {PostOneBillingTaxNumberValidationRequestBody} [postOneBillingTaxNumberValidationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody?: PostOneBillingTaxNumberValidationRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/billing/tax-number/validate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof postOneBillingTaxNumberValidationRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postOneBillingTaxNumberValidationRequestBody !== undefined ? postOneBillingTaxNumberValidationRequestBody : {}) : (postOneBillingTaxNumberValidationRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all Plans from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingPlans(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plan>> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getAllBillingPlans(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all Products from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingProducts(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getAllBillingProducts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all TaxRate\'s from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingTaxRates(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaxRate>> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getAllBillingTaxRates(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Index of billing endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingIndex(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getBillingIndex(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets one subscription plan from Stripe using Stripe subscription Id\'s.
         * @param {string} stripePlanId A Stripe Plan Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingPlan(stripePlanId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getOneBillingPlan(stripePlanId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets one Product from Stripe using Stripe Product Id.
         * @param {string} stripeProductId A Stripe Plan Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingProduct(stripeProductId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getOneBillingProduct(stripeProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets one Sales Tax response by countryCode.
         * @param {string} countryCode A Country code as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingSalesTax(countryCode: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesTax> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getOneBillingSalesTax(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets one TaxRate from Stripe using Stripe TaxRate Id.
         * @param {string} stripeTaxRateId A Stripe TaxRate Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingTaxRate(stripeTaxRateId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).getOneBillingTaxRate(stripeTaxRateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Validates a tax number.
         * @param {PostOneBillingTaxNumberValidationRequestBody} [postOneBillingTaxNumberValidationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody?: PostOneBillingTaxNumberValidationRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = BillingApiAxiosParamCreator(configuration).postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all Plans from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingPlans(options?: any): AxiosPromise<Array<Plan>> {
            return BillingApiFp(configuration).getAllBillingPlans(options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all Products from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingProducts(options?: any): AxiosPromise<Array<Product>> {
            return BillingApiFp(configuration).getAllBillingProducts(options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all TaxRate\'s from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingTaxRates(options?: any): AxiosPromise<Array<TaxRate>> {
            return BillingApiFp(configuration).getAllBillingTaxRates(options)(axios, basePath);
        },
        /**
         * 
         * @summary Index of billing endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingIndex(options?: any): AxiosPromise<Message> {
            return BillingApiFp(configuration).getBillingIndex(options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets one subscription plan from Stripe using Stripe subscription Id\'s.
         * @param {string} stripePlanId A Stripe Plan Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingPlan(stripePlanId: string, options?: any): AxiosPromise<Plan> {
            return BillingApiFp(configuration).getOneBillingPlan(stripePlanId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets one Product from Stripe using Stripe Product Id.
         * @param {string} stripeProductId A Stripe Plan Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingProduct(stripeProductId: string, options?: any): AxiosPromise<Product> {
            return BillingApiFp(configuration).getOneBillingProduct(stripeProductId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets one Sales Tax response by countryCode.
         * @param {string} countryCode A Country code as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingSalesTax(countryCode: string, options?: any): AxiosPromise<SalesTax> {
            return BillingApiFp(configuration).getOneBillingSalesTax(countryCode, options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets one TaxRate from Stripe using Stripe TaxRate Id.
         * @param {string} stripeTaxRateId A Stripe TaxRate Id as a string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneBillingTaxRate(stripeTaxRateId: string, options?: any): AxiosPromise<TaxRate> {
            return BillingApiFp(configuration).getOneBillingTaxRate(stripeTaxRateId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Validates a tax number.
         * @param {PostOneBillingTaxNumberValidationRequestBody} [postOneBillingTaxNumberValidationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody?: PostOneBillingTaxNumberValidationRequestBody, options?: any): AxiosPromise<Message> {
            return BillingApiFp(configuration).postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Get all Plans from Stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getAllBillingPlans(options?: any) {
        return BillingApiFp(this.configuration).getAllBillingPlans(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all Products from Stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getAllBillingProducts(options?: any) {
        return BillingApiFp(this.configuration).getAllBillingProducts(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all TaxRate\'s from Stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getAllBillingTaxRates(options?: any) {
        return BillingApiFp(this.configuration).getAllBillingTaxRates(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Index of billing endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getBillingIndex(options?: any) {
        return BillingApiFp(this.configuration).getBillingIndex(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets one subscription plan from Stripe using Stripe subscription Id\'s.
     * @param {string} stripePlanId A Stripe Plan Id as a string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOneBillingPlan(stripePlanId: string, options?: any) {
        return BillingApiFp(this.configuration).getOneBillingPlan(stripePlanId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets one Product from Stripe using Stripe Product Id.
     * @param {string} stripeProductId A Stripe Plan Id as a string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOneBillingProduct(stripeProductId: string, options?: any) {
        return BillingApiFp(this.configuration).getOneBillingProduct(stripeProductId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets one Sales Tax response by countryCode.
     * @param {string} countryCode A Country code as a string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOneBillingSalesTax(countryCode: string, options?: any) {
        return BillingApiFp(this.configuration).getOneBillingSalesTax(countryCode, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets one TaxRate from Stripe using Stripe TaxRate Id.
     * @param {string} stripeTaxRateId A Stripe TaxRate Id as a string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOneBillingTaxRate(stripeTaxRateId: string, options?: any) {
        return BillingApiFp(this.configuration).getOneBillingTaxRate(stripeTaxRateId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Validates a tax number.
     * @param {PostOneBillingTaxNumberValidationRequestBody} [postOneBillingTaxNumberValidationRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody?: PostOneBillingTaxNumberValidationRequestBody, options?: any) {
        return BillingApiFp(this.configuration).postOneBillingTaxNumberValidation(postOneBillingTaxNumberValidationRequestBody, options)(this.axios, this.basePath);
    }

}


/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options: any = {}): RequestArgs {
            const localVarPath = `/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountriesCollection> {
            const localVarAxiosArgs = CountriesApiAxiosParamCreator(configuration).getAllCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options?: any): AxiosPromise<CountriesCollection> {
            return CountriesApiFp(configuration).getAllCountries(options)(axios, basePath);
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * 
     * @summary Get all countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getAllCountries(options?: any) {
        return CountriesApiFp(this.configuration).getAllCountries(options)(this.axios, this.basePath);
    }

}


/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(options: any = {}): RequestArgs {
            const localVarPath = `/languages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguagesCollection> {
            const localVarAxiosArgs = LanguagesApiAxiosParamCreator(configuration).getAllLanguages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(options?: any): AxiosPromise<LanguagesCollection> {
            return LanguagesApiFp(configuration).getAllLanguages(options)(axios, basePath);
        },
    };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * 
     * @summary Get all languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public getAllLanguages(options?: any) {
        return LanguagesApiFp(this.configuration).getAllLanguages(options)(this.axios, this.basePath);
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(options: any = {}): RequestArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch the currently logged in user
         * @param {PatchOneUserRequestBody} [patchOneUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOneUser(patchOneUserRequestBody?: PatchOneUserRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Key"] = localVarApiKeyValue;
            }

            // authentication ApiSecretAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Api-Secret")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Api-Secret"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof patchOneUserRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOneUserRequestBody !== undefined ? patchOneUserRequestBody : {}) : (patchOneUserRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getOneUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Patch the currently logged in user
         * @param {PatchOneUserRequestBody} [patchOneUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOneUser(patchOneUserRequestBody?: PatchOneUserRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).patchOneUser(patchOneUserRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUser(options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getOneUser(options)(axios, basePath);
        },
        /**
         * 
         * @summary Patch the currently logged in user
         * @param {PatchOneUserRequestBody} [patchOneUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOneUser(patchOneUserRequestBody?: PatchOneUserRequestBody, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).patchOneUser(patchOneUserRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get the currently logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOneUser(options?: any) {
        return UserApiFp(this.configuration).getOneUser(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Patch the currently logged in user
     * @param {PatchOneUserRequestBody} [patchOneUserRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public patchOneUser(patchOneUserRequestBody?: PatchOneUserRequestBody, options?: any) {
        return UserApiFp(this.configuration).patchOneUser(patchOneUserRequestBody, options)(this.axios, this.basePath);
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a User
         * @param {PostUsersRequestBody} [postUsersRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(postUsersRequestBody?: PostUsersRequestBody, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof postUsersRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postUsersRequestBody !== undefined ? postUsersRequestBody : {}) : (postUsersRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a User
         * @param {PostUsersRequestBody} [postUsersRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(postUsersRequestBody?: PostUsersRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postUsers(postUsersRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a User
         * @param {PostUsersRequestBody} [postUsersRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(postUsersRequestBody?: PostUsersRequestBody, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).postUsers(postUsersRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a User
     * @param {PostUsersRequestBody} [postUsersRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsers(postUsersRequestBody?: PostUsersRequestBody, options?: any) {
        return UsersApiFp(this.configuration).postUsers(postUsersRequestBody, options)(this.axios, this.basePath);
    }

}


