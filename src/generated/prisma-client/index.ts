// Code generated by Prisma (prisma@1.26.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  archive: (where?: ArchiveWhereInput) => Promise<boolean>;
  article: (where?: ArticleWhereInput) => Promise<boolean>;
  audiofile: (where?: AudiofileWhereInput) => Promise<boolean>;
  favorite: (where?: FavoriteWhereInput) => Promise<boolean>;
  playlist: (where?: PlaylistWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  archives: (args?: {
    where?: ArchiveWhereInput;
    orderBy?: ArchiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Archive>;
  archivesConnection: (args?: {
    where?: ArchiveWhereInput;
    orderBy?: ArchiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ArchiveConnectionPromise;
  article: (where: ArticleWhereUniqueInput) => ArticlePromise;
  articles: (args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Article>;
  articlesConnection: (args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ArticleConnectionPromise;
  audiofile: (where: AudiofileWhereUniqueInput) => AudiofilePromise;
  audiofiles: (args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Audiofile>;
  audiofilesConnection: (args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AudiofileConnectionPromise;
  favorites: (args?: {
    where?: FavoriteWhereInput;
    orderBy?: FavoriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Favorite>;
  favoritesConnection: (args?: {
    where?: FavoriteWhereInput;
    orderBy?: FavoriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FavoriteConnectionPromise;
  playlists: (args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Playlist>;
  playlistsConnection: (args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaylistConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createArchive: (data: ArchiveCreateInput) => ArchivePromise;
  deleteManyArchives: (where?: ArchiveWhereInput) => BatchPayloadPromise;
  createArticle: (data: ArticleCreateInput) => ArticlePromise;
  updateArticle: (args: {
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
  }) => ArticlePromise;
  updateManyArticles: (args: {
    data: ArticleUpdateManyMutationInput;
    where?: ArticleWhereInput;
  }) => BatchPayloadPromise;
  upsertArticle: (args: {
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
  }) => ArticlePromise;
  deleteArticle: (where: ArticleWhereUniqueInput) => ArticlePromise;
  deleteManyArticles: (where?: ArticleWhereInput) => BatchPayloadPromise;
  createAudiofile: (data: AudiofileCreateInput) => AudiofilePromise;
  updateAudiofile: (args: {
    data: AudiofileUpdateInput;
    where: AudiofileWhereUniqueInput;
  }) => AudiofilePromise;
  updateManyAudiofiles: (args: {
    data: AudiofileUpdateManyMutationInput;
    where?: AudiofileWhereInput;
  }) => BatchPayloadPromise;
  upsertAudiofile: (args: {
    where: AudiofileWhereUniqueInput;
    create: AudiofileCreateInput;
    update: AudiofileUpdateInput;
  }) => AudiofilePromise;
  deleteAudiofile: (where: AudiofileWhereUniqueInput) => AudiofilePromise;
  deleteManyAudiofiles: (where?: AudiofileWhereInput) => BatchPayloadPromise;
  createFavorite: (data: FavoriteCreateInput) => FavoritePromise;
  deleteManyFavorites: (where?: FavoriteWhereInput) => BatchPayloadPromise;
  createPlaylist: (data: PlaylistCreateInput) => PlaylistPromise;
  updateManyPlaylists: (args: {
    data: PlaylistUpdateManyMutationInput;
    where?: PlaylistWhereInput;
  }) => BatchPayloadPromise;
  deleteManyPlaylists: (where?: PlaylistWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  archive: (
    where?: ArchiveSubscriptionWhereInput
  ) => ArchiveSubscriptionPayloadSubscription;
  article: (
    where?: ArticleSubscriptionWhereInput
  ) => ArticleSubscriptionPayloadSubscription;
  audiofile: (
    where?: AudiofileSubscriptionWhereInput
  ) => AudiofileSubscriptionPayloadSubscription;
  favorite: (
    where?: FavoriteSubscriptionWhereInput
  ) => FavoriteSubscriptionPayloadSubscription;
  playlist: (
    where?: PlaylistSubscriptionWhereInput
  ) => PlaylistSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Language = "EN";

export type Encoding = "MP3" | "OGG" | "PCM";

export type Synthesizer = "GOOGLE" | "AWS";

export type ArchiveOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type PlaylistOrderByInput =
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type AudiofileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "length_ASC"
  | "length_DESC"
  | "language_ASC"
  | "language_DESC"
  | "encoding_ASC"
  | "encoding_DESC"
  | "voice_ASC"
  | "voice_DESC"
  | "synthesizer_ASC"
  | "synthesizer_DESC"
  | "listens_ASC"
  | "listens_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FavoriteOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type ArticleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "readingTime_ASC"
  | "readingTime_DESC"
  | "language_ASC"
  | "language_DESC"
  | "authorName_ASC"
  | "authorName_DESC"
  | "authorUrl_ASC"
  | "authorUrl_DESC"
  | "categoryName_ASC"
  | "categoryName_DESC"
  | "html_ASC"
  | "html_DESC"
  | "ssml_ASC"
  | "ssml_DESC"
  | "text_ASC"
  | "text_DESC"
  | "sourceName_ASC"
  | "sourceName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "authenticatedAt_ASC"
  | "authenticatedAt_DESC"
  | "activatedAt_ASC"
  | "activatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ArchiveWhereInput {
  user?: UserWhereInput;
  article?: ArticleWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ArchiveWhereInput[] | ArchiveWhereInput;
  OR?: ArchiveWhereInput[] | ArchiveWhereInput;
  NOT?: ArchiveWhereInput[] | ArchiveWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  playlist_every?: PlaylistWhereInput;
  playlist_some?: PlaylistWhereInput;
  playlist_none?: PlaylistWhereInput;
  archive_every?: ArchiveWhereInput;
  archive_some?: ArchiveWhereInput;
  archive_none?: ArchiveWhereInput;
  favorites_every?: FavoriteWhereInput;
  favorites_some?: FavoriteWhereInput;
  favorites_none?: FavoriteWhereInput;
  articles_every?: ArticleWhereInput;
  articles_some?: ArticleWhereInput;
  articles_none?: ArticleWhereInput;
  authenticatedAt?: DateTimeInput;
  authenticatedAt_not?: DateTimeInput;
  authenticatedAt_in?: DateTimeInput[] | DateTimeInput;
  authenticatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  authenticatedAt_lt?: DateTimeInput;
  authenticatedAt_lte?: DateTimeInput;
  authenticatedAt_gt?: DateTimeInput;
  authenticatedAt_gte?: DateTimeInput;
  activatedAt?: DateTimeInput;
  activatedAt_not?: DateTimeInput;
  activatedAt_in?: DateTimeInput[] | DateTimeInput;
  activatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  activatedAt_lt?: DateTimeInput;
  activatedAt_lte?: DateTimeInput;
  activatedAt_gt?: DateTimeInput;
  activatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PlaylistWhereInput {
  user?: UserWhereInput;
  article?: ArticleWhereInput;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PlaylistWhereInput[] | PlaylistWhereInput;
  OR?: PlaylistWhereInput[] | PlaylistWhereInput;
  NOT?: PlaylistWhereInput[] | PlaylistWhereInput;
}

export interface ArticleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  imageUrl?: String;
  imageUrl_not?: String;
  imageUrl_in?: String[] | String;
  imageUrl_not_in?: String[] | String;
  imageUrl_lt?: String;
  imageUrl_lte?: String;
  imageUrl_gt?: String;
  imageUrl_gte?: String;
  imageUrl_contains?: String;
  imageUrl_not_contains?: String;
  imageUrl_starts_with?: String;
  imageUrl_not_starts_with?: String;
  imageUrl_ends_with?: String;
  imageUrl_not_ends_with?: String;
  readingTime?: Float;
  readingTime_not?: Float;
  readingTime_in?: Float[] | Float;
  readingTime_not_in?: Float[] | Float;
  readingTime_lt?: Float;
  readingTime_lte?: Float;
  readingTime_gt?: Float;
  readingTime_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  authorName?: String;
  authorName_not?: String;
  authorName_in?: String[] | String;
  authorName_not_in?: String[] | String;
  authorName_lt?: String;
  authorName_lte?: String;
  authorName_gt?: String;
  authorName_gte?: String;
  authorName_contains?: String;
  authorName_not_contains?: String;
  authorName_starts_with?: String;
  authorName_not_starts_with?: String;
  authorName_ends_with?: String;
  authorName_not_ends_with?: String;
  authorUrl?: String;
  authorUrl_not?: String;
  authorUrl_in?: String[] | String;
  authorUrl_not_in?: String[] | String;
  authorUrl_lt?: String;
  authorUrl_lte?: String;
  authorUrl_gt?: String;
  authorUrl_gte?: String;
  authorUrl_contains?: String;
  authorUrl_not_contains?: String;
  authorUrl_starts_with?: String;
  authorUrl_not_starts_with?: String;
  authorUrl_ends_with?: String;
  authorUrl_not_ends_with?: String;
  categoryName?: String;
  categoryName_not?: String;
  categoryName_in?: String[] | String;
  categoryName_not_in?: String[] | String;
  categoryName_lt?: String;
  categoryName_lte?: String;
  categoryName_gt?: String;
  categoryName_gte?: String;
  categoryName_contains?: String;
  categoryName_not_contains?: String;
  categoryName_starts_with?: String;
  categoryName_not_starts_with?: String;
  categoryName_ends_with?: String;
  categoryName_not_ends_with?: String;
  html?: String;
  html_not?: String;
  html_in?: String[] | String;
  html_not_in?: String[] | String;
  html_lt?: String;
  html_lte?: String;
  html_gt?: String;
  html_gte?: String;
  html_contains?: String;
  html_not_contains?: String;
  html_starts_with?: String;
  html_not_starts_with?: String;
  html_ends_with?: String;
  html_not_ends_with?: String;
  ssml?: String;
  ssml_not?: String;
  ssml_in?: String[] | String;
  ssml_not_in?: String[] | String;
  ssml_lt?: String;
  ssml_lte?: String;
  ssml_gt?: String;
  ssml_gte?: String;
  ssml_contains?: String;
  ssml_not_contains?: String;
  ssml_starts_with?: String;
  ssml_not_starts_with?: String;
  ssml_ends_with?: String;
  ssml_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  sourceName?: String;
  sourceName_not?: String;
  sourceName_in?: String[] | String;
  sourceName_not_in?: String[] | String;
  sourceName_lt?: String;
  sourceName_lte?: String;
  sourceName_gt?: String;
  sourceName_gte?: String;
  sourceName_contains?: String;
  sourceName_not_contains?: String;
  sourceName_starts_with?: String;
  sourceName_not_starts_with?: String;
  sourceName_ends_with?: String;
  sourceName_not_ends_with?: String;
  user?: UserWhereInput;
  audiofiles_every?: AudiofileWhereInput;
  audiofiles_some?: AudiofileWhereInput;
  audiofiles_none?: AudiofileWhereInput;
  playlists_every?: PlaylistWhereInput;
  playlists_some?: PlaylistWhereInput;
  playlists_none?: PlaylistWhereInput;
  archives_every?: ArchiveWhereInput;
  archives_some?: ArchiveWhereInput;
  archives_none?: ArchiveWhereInput;
  favorites_every?: FavoriteWhereInput;
  favorites_some?: FavoriteWhereInput;
  favorites_none?: FavoriteWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ArticleWhereInput[] | ArticleWhereInput;
  OR?: ArticleWhereInput[] | ArticleWhereInput;
  NOT?: ArticleWhereInput[] | ArticleWhereInput;
}

export interface AudiofileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  article?: ArticleWhereInput;
  length?: Float;
  length_not?: Float;
  length_in?: Float[] | Float;
  length_not_in?: Float[] | Float;
  length_lt?: Float;
  length_lte?: Float;
  length_gt?: Float;
  length_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  encoding?: Encoding;
  encoding_not?: Encoding;
  encoding_in?: Encoding[] | Encoding;
  encoding_not_in?: Encoding[] | Encoding;
  voice?: String;
  voice_not?: String;
  voice_in?: String[] | String;
  voice_not_in?: String[] | String;
  voice_lt?: String;
  voice_lte?: String;
  voice_gt?: String;
  voice_gte?: String;
  voice_contains?: String;
  voice_not_contains?: String;
  voice_starts_with?: String;
  voice_not_starts_with?: String;
  voice_ends_with?: String;
  voice_not_ends_with?: String;
  synthesizer?: Synthesizer;
  synthesizer_not?: Synthesizer;
  synthesizer_in?: Synthesizer[] | Synthesizer;
  synthesizer_not_in?: Synthesizer[] | Synthesizer;
  listens?: Int;
  listens_not?: Int;
  listens_in?: Int[] | Int;
  listens_not_in?: Int[] | Int;
  listens_lt?: Int;
  listens_lte?: Int;
  listens_gt?: Int;
  listens_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AudiofileWhereInput[] | AudiofileWhereInput;
  OR?: AudiofileWhereInput[] | AudiofileWhereInput;
  NOT?: AudiofileWhereInput[] | AudiofileWhereInput;
}

export interface FavoriteWhereInput {
  user?: UserWhereInput;
  article?: ArticleWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FavoriteWhereInput[] | FavoriteWhereInput;
  OR?: FavoriteWhereInput[] | FavoriteWhereInput;
  NOT?: FavoriteWhereInput[] | FavoriteWhereInput;
}

export type ArticleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export type AudiofileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ArchiveCreateInput {
  user: UserCreateOneWithoutArchiveInput;
  article: ArticleCreateOneWithoutArchivesInput;
}

export interface UserCreateOneWithoutArchiveInput {
  create?: UserCreateWithoutArchiveInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutArchiveInput {
  email: String;
  password: String;
  playlist?: PlaylistCreateManyWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  articles?: ArticleCreateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface PlaylistCreateManyWithoutUserInput {
  create?: PlaylistCreateWithoutUserInput[] | PlaylistCreateWithoutUserInput;
}

export interface PlaylistCreateWithoutUserInput {
  article: ArticleCreateOneWithoutPlaylistsInput;
  order: Int;
}

export interface ArticleCreateOneWithoutPlaylistsInput {
  create?: ArticleCreateWithoutPlaylistsInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutPlaylistsInput {
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserCreateOneWithoutArticlesInput;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  archives?: ArchiveCreateManyWithoutArticleInput;
  favorites?: FavoriteCreateManyWithoutArticleInput;
}

export interface UserCreateOneWithoutArticlesInput {
  create?: UserCreateWithoutArticlesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutArticlesInput {
  email: String;
  password: String;
  playlist?: PlaylistCreateManyWithoutUserInput;
  archive?: ArchiveCreateManyWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface ArchiveCreateManyWithoutUserInput {
  create?: ArchiveCreateWithoutUserInput[] | ArchiveCreateWithoutUserInput;
}

export interface ArchiveCreateWithoutUserInput {
  article: ArticleCreateOneWithoutArchivesInput;
}

export interface ArticleCreateOneWithoutArchivesInput {
  create?: ArticleCreateWithoutArchivesInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutArchivesInput {
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserCreateOneWithoutArticlesInput;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  playlists?: PlaylistCreateManyWithoutArticleInput;
  favorites?: FavoriteCreateManyWithoutArticleInput;
}

export interface AudiofileCreateManyWithoutArticleInput {
  create?:
    | AudiofileCreateWithoutArticleInput[]
    | AudiofileCreateWithoutArticleInput;
  connect?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
}

export interface AudiofileCreateWithoutArticleInput {
  url: String;
  length: Float;
  language: Language;
  encoding: Encoding;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
}

export interface PlaylistCreateManyWithoutArticleInput {
  create?:
    | PlaylistCreateWithoutArticleInput[]
    | PlaylistCreateWithoutArticleInput;
}

export interface PlaylistCreateWithoutArticleInput {
  user: UserCreateOneWithoutPlaylistInput;
  order: Int;
}

export interface UserCreateOneWithoutPlaylistInput {
  create?: UserCreateWithoutPlaylistInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPlaylistInput {
  email: String;
  password: String;
  archive?: ArchiveCreateManyWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  articles?: ArticleCreateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface FavoriteCreateManyWithoutUserInput {
  create?: FavoriteCreateWithoutUserInput[] | FavoriteCreateWithoutUserInput;
}

export interface FavoriteCreateWithoutUserInput {
  article: ArticleCreateOneWithoutFavoritesInput;
}

export interface ArticleCreateOneWithoutFavoritesInput {
  create?: ArticleCreateWithoutFavoritesInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutFavoritesInput {
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserCreateOneWithoutArticlesInput;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  playlists?: PlaylistCreateManyWithoutArticleInput;
  archives?: ArchiveCreateManyWithoutArticleInput;
}

export interface ArchiveCreateManyWithoutArticleInput {
  create?:
    | ArchiveCreateWithoutArticleInput[]
    | ArchiveCreateWithoutArticleInput;
}

export interface ArchiveCreateWithoutArticleInput {
  user: UserCreateOneWithoutArchiveInput;
}

export interface ArticleCreateManyWithoutUserInput {
  create?: ArticleCreateWithoutUserInput[] | ArticleCreateWithoutUserInput;
  connect?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutUserInput {
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  playlists?: PlaylistCreateManyWithoutArticleInput;
  archives?: ArchiveCreateManyWithoutArticleInput;
  favorites?: FavoriteCreateManyWithoutArticleInput;
}

export interface FavoriteCreateManyWithoutArticleInput {
  create?:
    | FavoriteCreateWithoutArticleInput[]
    | FavoriteCreateWithoutArticleInput;
}

export interface FavoriteCreateWithoutArticleInput {
  user: UserCreateOneWithoutFavoritesInput;
}

export interface UserCreateOneWithoutFavoritesInput {
  create?: UserCreateWithoutFavoritesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutFavoritesInput {
  email: String;
  password: String;
  playlist?: PlaylistCreateManyWithoutUserInput;
  archive?: ArchiveCreateManyWithoutUserInput;
  articles?: ArticleCreateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface ArticleCreateInput {
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserCreateOneWithoutArticlesInput;
  audiofiles?: AudiofileCreateManyWithoutArticleInput;
  playlists?: PlaylistCreateManyWithoutArticleInput;
  archives?: ArchiveCreateManyWithoutArticleInput;
  favorites?: FavoriteCreateManyWithoutArticleInput;
}

export interface ArticleUpdateInput {
  title?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserUpdateOneWithoutArticlesInput;
  audiofiles?: AudiofileUpdateManyWithoutArticleInput;
  playlists?: PlaylistUpdateManyWithoutArticleInput;
  archives?: ArchiveUpdateManyWithoutArticleInput;
  favorites?: FavoriteUpdateManyWithoutArticleInput;
}

export interface UserUpdateOneWithoutArticlesInput {
  create?: UserCreateWithoutArticlesInput;
  update?: UserUpdateWithoutArticlesDataInput;
  upsert?: UserUpsertWithoutArticlesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutArticlesDataInput {
  email?: String;
  password?: String;
  playlist?: PlaylistUpdateManyWithoutUserInput;
  archive?: ArchiveUpdateManyWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface PlaylistUpdateManyWithoutUserInput {
  create?: PlaylistCreateWithoutUserInput[] | PlaylistCreateWithoutUserInput;
  deleteMany?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  updateMany?:
    | PlaylistUpdateManyWithWhereNestedInput[]
    | PlaylistUpdateManyWithWhereNestedInput;
}

export interface PlaylistScalarWhereInput {
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  OR?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  NOT?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
}

export interface PlaylistUpdateManyWithWhereNestedInput {
  where: PlaylistScalarWhereInput;
  data: PlaylistUpdateManyDataInput;
}

export interface PlaylistUpdateManyDataInput {
  order?: Int;
}

export interface ArchiveUpdateManyWithoutUserInput {
  create?: ArchiveCreateWithoutUserInput[] | ArchiveCreateWithoutUserInput;
  deleteMany?: ArchiveScalarWhereInput[] | ArchiveScalarWhereInput;
}

export interface ArchiveScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ArchiveScalarWhereInput[] | ArchiveScalarWhereInput;
  OR?: ArchiveScalarWhereInput[] | ArchiveScalarWhereInput;
  NOT?: ArchiveScalarWhereInput[] | ArchiveScalarWhereInput;
}

export interface FavoriteUpdateManyWithoutUserInput {
  create?: FavoriteCreateWithoutUserInput[] | FavoriteCreateWithoutUserInput;
  deleteMany?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export interface FavoriteScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  OR?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  NOT?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export interface UserUpsertWithoutArticlesInput {
  update: UserUpdateWithoutArticlesDataInput;
  create: UserCreateWithoutArticlesInput;
}

export interface AudiofileUpdateManyWithoutArticleInput {
  create?:
    | AudiofileCreateWithoutArticleInput[]
    | AudiofileCreateWithoutArticleInput;
  delete?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  connect?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  set?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  disconnect?: AudiofileWhereUniqueInput[] | AudiofileWhereUniqueInput;
  update?:
    | AudiofileUpdateWithWhereUniqueWithoutArticleInput[]
    | AudiofileUpdateWithWhereUniqueWithoutArticleInput;
  upsert?:
    | AudiofileUpsertWithWhereUniqueWithoutArticleInput[]
    | AudiofileUpsertWithWhereUniqueWithoutArticleInput;
  deleteMany?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
  updateMany?:
    | AudiofileUpdateManyWithWhereNestedInput[]
    | AudiofileUpdateManyWithWhereNestedInput;
}

export interface AudiofileUpdateWithWhereUniqueWithoutArticleInput {
  where: AudiofileWhereUniqueInput;
  data: AudiofileUpdateWithoutArticleDataInput;
}

export interface AudiofileUpdateWithoutArticleDataInput {
  url?: String;
  length?: Float;
  language?: Language;
  encoding?: Encoding;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface AudiofileUpsertWithWhereUniqueWithoutArticleInput {
  where: AudiofileWhereUniqueInput;
  update: AudiofileUpdateWithoutArticleDataInput;
  create: AudiofileCreateWithoutArticleInput;
}

export interface AudiofileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  length?: Float;
  length_not?: Float;
  length_in?: Float[] | Float;
  length_not_in?: Float[] | Float;
  length_lt?: Float;
  length_lte?: Float;
  length_gt?: Float;
  length_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  encoding?: Encoding;
  encoding_not?: Encoding;
  encoding_in?: Encoding[] | Encoding;
  encoding_not_in?: Encoding[] | Encoding;
  voice?: String;
  voice_not?: String;
  voice_in?: String[] | String;
  voice_not_in?: String[] | String;
  voice_lt?: String;
  voice_lte?: String;
  voice_gt?: String;
  voice_gte?: String;
  voice_contains?: String;
  voice_not_contains?: String;
  voice_starts_with?: String;
  voice_not_starts_with?: String;
  voice_ends_with?: String;
  voice_not_ends_with?: String;
  synthesizer?: Synthesizer;
  synthesizer_not?: Synthesizer;
  synthesizer_in?: Synthesizer[] | Synthesizer;
  synthesizer_not_in?: Synthesizer[] | Synthesizer;
  listens?: Int;
  listens_not?: Int;
  listens_in?: Int[] | Int;
  listens_not_in?: Int[] | Int;
  listens_lt?: Int;
  listens_lte?: Int;
  listens_gt?: Int;
  listens_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
  OR?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
  NOT?: AudiofileScalarWhereInput[] | AudiofileScalarWhereInput;
}

export interface AudiofileUpdateManyWithWhereNestedInput {
  where: AudiofileScalarWhereInput;
  data: AudiofileUpdateManyDataInput;
}

export interface AudiofileUpdateManyDataInput {
  url?: String;
  length?: Float;
  language?: Language;
  encoding?: Encoding;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface PlaylistUpdateManyWithoutArticleInput {
  create?:
    | PlaylistCreateWithoutArticleInput[]
    | PlaylistCreateWithoutArticleInput;
  deleteMany?: PlaylistScalarWhereInput[] | PlaylistScalarWhereInput;
  updateMany?:
    | PlaylistUpdateManyWithWhereNestedInput[]
    | PlaylistUpdateManyWithWhereNestedInput;
}

export interface ArchiveUpdateManyWithoutArticleInput {
  create?:
    | ArchiveCreateWithoutArticleInput[]
    | ArchiveCreateWithoutArticleInput;
  deleteMany?: ArchiveScalarWhereInput[] | ArchiveScalarWhereInput;
}

export interface FavoriteUpdateManyWithoutArticleInput {
  create?:
    | FavoriteCreateWithoutArticleInput[]
    | FavoriteCreateWithoutArticleInput;
  deleteMany?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export interface ArticleUpdateManyMutationInput {
  title?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
}

export interface AudiofileCreateInput {
  url: String;
  article: ArticleCreateOneWithoutAudiofilesInput;
  length: Float;
  language: Language;
  encoding: Encoding;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
}

export interface ArticleCreateOneWithoutAudiofilesInput {
  create?: ArticleCreateWithoutAudiofilesInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleCreateWithoutAudiofilesInput {
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserCreateOneWithoutArticlesInput;
  playlists?: PlaylistCreateManyWithoutArticleInput;
  archives?: ArchiveCreateManyWithoutArticleInput;
  favorites?: FavoriteCreateManyWithoutArticleInput;
}

export interface AudiofileUpdateInput {
  url?: String;
  article?: ArticleUpdateOneRequiredWithoutAudiofilesInput;
  length?: Float;
  language?: Language;
  encoding?: Encoding;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface ArticleUpdateOneRequiredWithoutAudiofilesInput {
  create?: ArticleCreateWithoutAudiofilesInput;
  update?: ArticleUpdateWithoutAudiofilesDataInput;
  upsert?: ArticleUpsertWithoutAudiofilesInput;
  connect?: ArticleWhereUniqueInput;
}

export interface ArticleUpdateWithoutAudiofilesDataInput {
  title?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  user?: UserUpdateOneWithoutArticlesInput;
  playlists?: PlaylistUpdateManyWithoutArticleInput;
  archives?: ArchiveUpdateManyWithoutArticleInput;
  favorites?: FavoriteUpdateManyWithoutArticleInput;
}

export interface ArticleUpsertWithoutAudiofilesInput {
  update: ArticleUpdateWithoutAudiofilesDataInput;
  create: ArticleCreateWithoutAudiofilesInput;
}

export interface AudiofileUpdateManyMutationInput {
  url?: String;
  length?: Float;
  language?: Language;
  encoding?: Encoding;
  voice?: String;
  synthesizer?: Synthesizer;
  listens?: Int;
}

export interface FavoriteCreateInput {
  user: UserCreateOneWithoutFavoritesInput;
  article: ArticleCreateOneWithoutFavoritesInput;
}

export interface PlaylistCreateInput {
  user: UserCreateOneWithoutPlaylistInput;
  article: ArticleCreateOneWithoutPlaylistsInput;
  order: Int;
}

export interface PlaylistUpdateManyMutationInput {
  order?: Int;
}

export interface UserCreateInput {
  email: String;
  password: String;
  playlist?: PlaylistCreateManyWithoutUserInput;
  archive?: ArchiveCreateManyWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  articles?: ArticleCreateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  playlist?: PlaylistUpdateManyWithoutUserInput;
  archive?: ArchiveUpdateManyWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  articles?: ArticleUpdateManyWithoutUserInput;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface ArticleUpdateManyWithoutUserInput {
  create?: ArticleCreateWithoutUserInput[] | ArticleCreateWithoutUserInput;
  delete?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  connect?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  set?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  disconnect?: ArticleWhereUniqueInput[] | ArticleWhereUniqueInput;
  update?:
    | ArticleUpdateWithWhereUniqueWithoutUserInput[]
    | ArticleUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ArticleUpsertWithWhereUniqueWithoutUserInput[]
    | ArticleUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
  updateMany?:
    | ArticleUpdateManyWithWhereNestedInput[]
    | ArticleUpdateManyWithWhereNestedInput;
}

export interface ArticleUpdateWithWhereUniqueWithoutUserInput {
  where: ArticleWhereUniqueInput;
  data: ArticleUpdateWithoutUserDataInput;
}

export interface ArticleUpdateWithoutUserDataInput {
  title?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  audiofiles?: AudiofileUpdateManyWithoutArticleInput;
  playlists?: PlaylistUpdateManyWithoutArticleInput;
  archives?: ArchiveUpdateManyWithoutArticleInput;
  favorites?: FavoriteUpdateManyWithoutArticleInput;
}

export interface ArticleUpsertWithWhereUniqueWithoutUserInput {
  where: ArticleWhereUniqueInput;
  update: ArticleUpdateWithoutUserDataInput;
  create: ArticleCreateWithoutUserInput;
}

export interface ArticleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  imageUrl?: String;
  imageUrl_not?: String;
  imageUrl_in?: String[] | String;
  imageUrl_not_in?: String[] | String;
  imageUrl_lt?: String;
  imageUrl_lte?: String;
  imageUrl_gt?: String;
  imageUrl_gte?: String;
  imageUrl_contains?: String;
  imageUrl_not_contains?: String;
  imageUrl_starts_with?: String;
  imageUrl_not_starts_with?: String;
  imageUrl_ends_with?: String;
  imageUrl_not_ends_with?: String;
  readingTime?: Float;
  readingTime_not?: Float;
  readingTime_in?: Float[] | Float;
  readingTime_not_in?: Float[] | Float;
  readingTime_lt?: Float;
  readingTime_lte?: Float;
  readingTime_gt?: Float;
  readingTime_gte?: Float;
  language?: Language;
  language_not?: Language;
  language_in?: Language[] | Language;
  language_not_in?: Language[] | Language;
  authorName?: String;
  authorName_not?: String;
  authorName_in?: String[] | String;
  authorName_not_in?: String[] | String;
  authorName_lt?: String;
  authorName_lte?: String;
  authorName_gt?: String;
  authorName_gte?: String;
  authorName_contains?: String;
  authorName_not_contains?: String;
  authorName_starts_with?: String;
  authorName_not_starts_with?: String;
  authorName_ends_with?: String;
  authorName_not_ends_with?: String;
  authorUrl?: String;
  authorUrl_not?: String;
  authorUrl_in?: String[] | String;
  authorUrl_not_in?: String[] | String;
  authorUrl_lt?: String;
  authorUrl_lte?: String;
  authorUrl_gt?: String;
  authorUrl_gte?: String;
  authorUrl_contains?: String;
  authorUrl_not_contains?: String;
  authorUrl_starts_with?: String;
  authorUrl_not_starts_with?: String;
  authorUrl_ends_with?: String;
  authorUrl_not_ends_with?: String;
  categoryName?: String;
  categoryName_not?: String;
  categoryName_in?: String[] | String;
  categoryName_not_in?: String[] | String;
  categoryName_lt?: String;
  categoryName_lte?: String;
  categoryName_gt?: String;
  categoryName_gte?: String;
  categoryName_contains?: String;
  categoryName_not_contains?: String;
  categoryName_starts_with?: String;
  categoryName_not_starts_with?: String;
  categoryName_ends_with?: String;
  categoryName_not_ends_with?: String;
  html?: String;
  html_not?: String;
  html_in?: String[] | String;
  html_not_in?: String[] | String;
  html_lt?: String;
  html_lte?: String;
  html_gt?: String;
  html_gte?: String;
  html_contains?: String;
  html_not_contains?: String;
  html_starts_with?: String;
  html_not_starts_with?: String;
  html_ends_with?: String;
  html_not_ends_with?: String;
  ssml?: String;
  ssml_not?: String;
  ssml_in?: String[] | String;
  ssml_not_in?: String[] | String;
  ssml_lt?: String;
  ssml_lte?: String;
  ssml_gt?: String;
  ssml_gte?: String;
  ssml_contains?: String;
  ssml_not_contains?: String;
  ssml_starts_with?: String;
  ssml_not_starts_with?: String;
  ssml_ends_with?: String;
  ssml_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  sourceName?: String;
  sourceName_not?: String;
  sourceName_in?: String[] | String;
  sourceName_not_in?: String[] | String;
  sourceName_lt?: String;
  sourceName_lte?: String;
  sourceName_gt?: String;
  sourceName_gte?: String;
  sourceName_contains?: String;
  sourceName_not_contains?: String;
  sourceName_starts_with?: String;
  sourceName_not_starts_with?: String;
  sourceName_ends_with?: String;
  sourceName_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
  OR?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
  NOT?: ArticleScalarWhereInput[] | ArticleScalarWhereInput;
}

export interface ArticleUpdateManyWithWhereNestedInput {
  where: ArticleScalarWhereInput;
  data: ArticleUpdateManyDataInput;
}

export interface ArticleUpdateManyDataInput {
  title?: String;
  description?: String;
  url?: String;
  imageUrl?: String;
  readingTime?: Float;
  language?: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
  authenticatedAt?: DateTimeInput;
  activatedAt?: DateTimeInput;
}

export interface ArchiveSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArchiveWhereInput;
  AND?: ArchiveSubscriptionWhereInput[] | ArchiveSubscriptionWhereInput;
  OR?: ArchiveSubscriptionWhereInput[] | ArchiveSubscriptionWhereInput;
  NOT?: ArchiveSubscriptionWhereInput[] | ArchiveSubscriptionWhereInput;
}

export interface ArticleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArticleWhereInput;
  AND?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
  OR?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
  NOT?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
}

export interface AudiofileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AudiofileWhereInput;
  AND?: AudiofileSubscriptionWhereInput[] | AudiofileSubscriptionWhereInput;
  OR?: AudiofileSubscriptionWhereInput[] | AudiofileSubscriptionWhereInput;
  NOT?: AudiofileSubscriptionWhereInput[] | AudiofileSubscriptionWhereInput;
}

export interface FavoriteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FavoriteWhereInput;
  AND?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
  OR?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
  NOT?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
}

export interface PlaylistSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlaylistWhereInput;
  AND?: PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput;
  OR?: PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput;
  NOT?: PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Archive {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArchivePromise extends Promise<Archive>, Fragmentable {
  user: <T = UserPromise>() => T;
  article: <T = ArticlePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArchiveSubscription
  extends Promise<AsyncIterator<Archive>>,
    Fragmentable {
  user: <T = UserSubscription>() => T;
  article: <T = ArticleSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  authenticatedAt?: DateTimeOutput;
  activatedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  playlist: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  archive: <T = FragmentableArray<Archive>>(args?: {
    where?: ArchiveWhereInput;
    orderBy?: ArchiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favorites: <T = FragmentableArray<Favorite>>(args?: {
    where?: FavoriteWhereInput;
    orderBy?: FavoriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  articles: <T = FragmentableArray<Article>>(args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authenticatedAt: () => Promise<DateTimeOutput>;
  activatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  playlist: <T = Promise<AsyncIterator<PlaylistSubscription>>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  archive: <T = Promise<AsyncIterator<ArchiveSubscription>>>(args?: {
    where?: ArchiveWhereInput;
    orderBy?: ArchiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favorites: <T = Promise<AsyncIterator<FavoriteSubscription>>>(args?: {
    where?: FavoriteWhereInput;
    orderBy?: FavoriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  articles: <T = Promise<AsyncIterator<ArticleSubscription>>>(args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authenticatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  activatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Playlist {
  order: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlaylistPromise extends Promise<Playlist>, Fragmentable {
  user: <T = UserPromise>() => T;
  article: <T = ArticlePromise>() => T;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistSubscription
  extends Promise<AsyncIterator<Playlist>>,
    Fragmentable {
  user: <T = UserSubscription>() => T;
  article: <T = ArticleSubscription>() => T;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Article {
  id: ID_Output;
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArticlePromise extends Promise<Article>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  imageUrl: () => Promise<String>;
  readingTime: () => Promise<Float>;
  language: () => Promise<Language>;
  authorName: () => Promise<String>;
  authorUrl: () => Promise<String>;
  categoryName: () => Promise<String>;
  html: () => Promise<String>;
  ssml: () => Promise<String>;
  text: () => Promise<String>;
  sourceName: () => Promise<String>;
  user: <T = UserPromise>() => T;
  audiofiles: <T = FragmentableArray<Audiofile>>(args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  playlists: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  archives: <T = FragmentableArray<Archive>>(args?: {
    where?: ArchiveWhereInput;
    orderBy?: ArchiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favorites: <T = FragmentableArray<Favorite>>(args?: {
    where?: FavoriteWhereInput;
    orderBy?: FavoriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArticleSubscription
  extends Promise<AsyncIterator<Article>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  readingTime: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  authorName: () => Promise<AsyncIterator<String>>;
  authorUrl: () => Promise<AsyncIterator<String>>;
  categoryName: () => Promise<AsyncIterator<String>>;
  html: () => Promise<AsyncIterator<String>>;
  ssml: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  sourceName: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  audiofiles: <T = Promise<AsyncIterator<AudiofileSubscription>>>(args?: {
    where?: AudiofileWhereInput;
    orderBy?: AudiofileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  playlists: <T = Promise<AsyncIterator<PlaylistSubscription>>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  archives: <T = Promise<AsyncIterator<ArchiveSubscription>>>(args?: {
    where?: ArchiveWhereInput;
    orderBy?: ArchiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  favorites: <T = Promise<AsyncIterator<FavoriteSubscription>>>(args?: {
    where?: FavoriteWhereInput;
    orderBy?: FavoriteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Audiofile {
  id: ID_Output;
  url: String;
  length: Float;
  language: Language;
  encoding: Encoding;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AudiofilePromise extends Promise<Audiofile>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  article: <T = ArticlePromise>() => T;
  length: () => Promise<Float>;
  language: () => Promise<Language>;
  encoding: () => Promise<Encoding>;
  voice: () => Promise<String>;
  synthesizer: () => Promise<Synthesizer>;
  listens: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AudiofileSubscription
  extends Promise<AsyncIterator<Audiofile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  article: <T = ArticleSubscription>() => T;
  length: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  encoding: () => Promise<AsyncIterator<Encoding>>;
  voice: () => Promise<AsyncIterator<String>>;
  synthesizer: () => Promise<AsyncIterator<Synthesizer>>;
  listens: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Favorite {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FavoritePromise extends Promise<Favorite>, Fragmentable {
  user: <T = UserPromise>() => T;
  article: <T = ArticlePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavoriteSubscription
  extends Promise<AsyncIterator<Favorite>>,
    Fragmentable {
  user: <T = UserSubscription>() => T;
  article: <T = ArticleSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ArchiveConnection {
  pageInfo: PageInfo;
  edges: ArchiveEdge[];
}

export interface ArchiveConnectionPromise
  extends Promise<ArchiveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArchiveEdge>>() => T;
  aggregate: <T = AggregateArchivePromise>() => T;
}

export interface ArchiveConnectionSubscription
  extends Promise<AsyncIterator<ArchiveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArchiveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArchiveSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ArchiveEdge {
  node: Archive;
  cursor: String;
}

export interface ArchiveEdgePromise extends Promise<ArchiveEdge>, Fragmentable {
  node: <T = ArchivePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArchiveEdgeSubscription
  extends Promise<AsyncIterator<ArchiveEdge>>,
    Fragmentable {
  node: <T = ArchiveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArchive {
  count: Int;
}

export interface AggregateArchivePromise
  extends Promise<AggregateArchive>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArchiveSubscription
  extends Promise<AsyncIterator<AggregateArchive>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArticleConnection {
  pageInfo: PageInfo;
  edges: ArticleEdge[];
}

export interface ArticleConnectionPromise
  extends Promise<ArticleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArticleEdge>>() => T;
  aggregate: <T = AggregateArticlePromise>() => T;
}

export interface ArticleConnectionSubscription
  extends Promise<AsyncIterator<ArticleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArticleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArticleSubscription>() => T;
}

export interface ArticleEdge {
  node: Article;
  cursor: String;
}

export interface ArticleEdgePromise extends Promise<ArticleEdge>, Fragmentable {
  node: <T = ArticlePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArticleEdgeSubscription
  extends Promise<AsyncIterator<ArticleEdge>>,
    Fragmentable {
  node: <T = ArticleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArticle {
  count: Int;
}

export interface AggregateArticlePromise
  extends Promise<AggregateArticle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArticleSubscription
  extends Promise<AsyncIterator<AggregateArticle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AudiofileConnection {
  pageInfo: PageInfo;
  edges: AudiofileEdge[];
}

export interface AudiofileConnectionPromise
  extends Promise<AudiofileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AudiofileEdge>>() => T;
  aggregate: <T = AggregateAudiofilePromise>() => T;
}

export interface AudiofileConnectionSubscription
  extends Promise<AsyncIterator<AudiofileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AudiofileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAudiofileSubscription>() => T;
}

export interface AudiofileEdge {
  node: Audiofile;
  cursor: String;
}

export interface AudiofileEdgePromise
  extends Promise<AudiofileEdge>,
    Fragmentable {
  node: <T = AudiofilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AudiofileEdgeSubscription
  extends Promise<AsyncIterator<AudiofileEdge>>,
    Fragmentable {
  node: <T = AudiofileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAudiofile {
  count: Int;
}

export interface AggregateAudiofilePromise
  extends Promise<AggregateAudiofile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAudiofileSubscription
  extends Promise<AsyncIterator<AggregateAudiofile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FavoriteConnection {
  pageInfo: PageInfo;
  edges: FavoriteEdge[];
}

export interface FavoriteConnectionPromise
  extends Promise<FavoriteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FavoriteEdge>>() => T;
  aggregate: <T = AggregateFavoritePromise>() => T;
}

export interface FavoriteConnectionSubscription
  extends Promise<AsyncIterator<FavoriteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FavoriteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFavoriteSubscription>() => T;
}

export interface FavoriteEdge {
  node: Favorite;
  cursor: String;
}

export interface FavoriteEdgePromise
  extends Promise<FavoriteEdge>,
    Fragmentable {
  node: <T = FavoritePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FavoriteEdgeSubscription
  extends Promise<AsyncIterator<FavoriteEdge>>,
    Fragmentable {
  node: <T = FavoriteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFavorite {
  count: Int;
}

export interface AggregateFavoritePromise
  extends Promise<AggregateFavorite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFavoriteSubscription
  extends Promise<AsyncIterator<AggregateFavorite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaylistConnection {
  pageInfo: PageInfo;
  edges: PlaylistEdge[];
}

export interface PlaylistConnectionPromise
  extends Promise<PlaylistConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaylistEdge>>() => T;
  aggregate: <T = AggregatePlaylistPromise>() => T;
}

export interface PlaylistConnectionSubscription
  extends Promise<AsyncIterator<PlaylistConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaylistEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaylistSubscription>() => T;
}

export interface PlaylistEdge {
  node: Playlist;
  cursor: String;
}

export interface PlaylistEdgePromise
  extends Promise<PlaylistEdge>,
    Fragmentable {
  node: <T = PlaylistPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaylistEdgeSubscription
  extends Promise<AsyncIterator<PlaylistEdge>>,
    Fragmentable {
  node: <T = PlaylistSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaylist {
  count: Int;
}

export interface AggregatePlaylistPromise
  extends Promise<AggregatePlaylist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaylistSubscription
  extends Promise<AsyncIterator<AggregatePlaylist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ArchiveSubscriptionPayload {
  mutation: MutationType;
  node: Archive;
  updatedFields: String[];
  previousValues: ArchivePreviousValues;
}

export interface ArchiveSubscriptionPayloadPromise
  extends Promise<ArchiveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArchivePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArchivePreviousValuesPromise>() => T;
}

export interface ArchiveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArchiveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArchiveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArchivePreviousValuesSubscription>() => T;
}

export interface ArchivePreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArchivePreviousValuesPromise
  extends Promise<ArchivePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArchivePreviousValuesSubscription
  extends Promise<AsyncIterator<ArchivePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ArticleSubscriptionPayload {
  mutation: MutationType;
  node: Article;
  updatedFields: String[];
  previousValues: ArticlePreviousValues;
}

export interface ArticleSubscriptionPayloadPromise
  extends Promise<ArticleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArticlePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArticlePreviousValuesPromise>() => T;
}

export interface ArticleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArticleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArticleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArticlePreviousValuesSubscription>() => T;
}

export interface ArticlePreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  url: String;
  imageUrl?: String;
  readingTime?: Float;
  language: Language;
  authorName?: String;
  authorUrl?: String;
  categoryName?: String;
  html?: String;
  ssml?: String;
  text?: String;
  sourceName?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArticlePreviousValuesPromise
  extends Promise<ArticlePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  imageUrl: () => Promise<String>;
  readingTime: () => Promise<Float>;
  language: () => Promise<Language>;
  authorName: () => Promise<String>;
  authorUrl: () => Promise<String>;
  categoryName: () => Promise<String>;
  html: () => Promise<String>;
  ssml: () => Promise<String>;
  text: () => Promise<String>;
  sourceName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArticlePreviousValuesSubscription
  extends Promise<AsyncIterator<ArticlePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  readingTime: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  authorName: () => Promise<AsyncIterator<String>>;
  authorUrl: () => Promise<AsyncIterator<String>>;
  categoryName: () => Promise<AsyncIterator<String>>;
  html: () => Promise<AsyncIterator<String>>;
  ssml: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  sourceName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AudiofileSubscriptionPayload {
  mutation: MutationType;
  node: Audiofile;
  updatedFields: String[];
  previousValues: AudiofilePreviousValues;
}

export interface AudiofileSubscriptionPayloadPromise
  extends Promise<AudiofileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AudiofilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AudiofilePreviousValuesPromise>() => T;
}

export interface AudiofileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AudiofileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AudiofileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AudiofilePreviousValuesSubscription>() => T;
}

export interface AudiofilePreviousValues {
  id: ID_Output;
  url: String;
  length: Float;
  language: Language;
  encoding: Encoding;
  voice: String;
  synthesizer: Synthesizer;
  listens?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AudiofilePreviousValuesPromise
  extends Promise<AudiofilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  length: () => Promise<Float>;
  language: () => Promise<Language>;
  encoding: () => Promise<Encoding>;
  voice: () => Promise<String>;
  synthesizer: () => Promise<Synthesizer>;
  listens: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AudiofilePreviousValuesSubscription
  extends Promise<AsyncIterator<AudiofilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Float>>;
  language: () => Promise<AsyncIterator<Language>>;
  encoding: () => Promise<AsyncIterator<Encoding>>;
  voice: () => Promise<AsyncIterator<String>>;
  synthesizer: () => Promise<AsyncIterator<Synthesizer>>;
  listens: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FavoriteSubscriptionPayload {
  mutation: MutationType;
  node: Favorite;
  updatedFields: String[];
  previousValues: FavoritePreviousValues;
}

export interface FavoriteSubscriptionPayloadPromise
  extends Promise<FavoriteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FavoritePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FavoritePreviousValuesPromise>() => T;
}

export interface FavoriteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FavoriteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FavoriteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FavoritePreviousValuesSubscription>() => T;
}

export interface FavoritePreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FavoritePreviousValuesPromise
  extends Promise<FavoritePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavoritePreviousValuesSubscription
  extends Promise<AsyncIterator<FavoritePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaylistSubscriptionPayload {
  mutation: MutationType;
  node: Playlist;
  updatedFields: String[];
  previousValues: PlaylistPreviousValues;
}

export interface PlaylistSubscriptionPayloadPromise
  extends Promise<PlaylistSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaylistPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaylistPreviousValuesPromise>() => T;
}

export interface PlaylistSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaylistSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaylistSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaylistPreviousValuesSubscription>() => T;
}

export interface PlaylistPreviousValues {
  order: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlaylistPreviousValuesPromise
  extends Promise<PlaylistPreviousValues>,
    Fragmentable {
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaylistPreviousValues>>,
    Fragmentable {
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  authenticatedAt?: DateTimeOutput;
  activatedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  authenticatedAt: () => Promise<DateTimeOutput>;
  activatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  authenticatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  activatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Archive",
    embedded: false
  },
  {
    name: "Article",
    embedded: false
  },
  {
    name: "Audiofile",
    embedded: false
  },
  {
    name: "Encoding",
    embedded: false
  },
  {
    name: "Favorite",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Playlist",
    embedded: false
  },
  {
    name: "Synthesizer",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `MQ1gswkegQ793ZMO0zveHLnx46VVOHSz`
});
export const prisma = new Prisma();
